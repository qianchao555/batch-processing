### 树

### 为什么需要树结构

1. 数组存储方式分析
   1. 通过下表访问，速度快
   2. 但是删除、插入效率低 ：需要移动位置
2. 链表存储方式分析
   1. 插入、删除效率高
   2. 但是查询速度慢，需要遍历整个链表
3. 树存储结构分析
   1. 能提高数据存储、读取的效率
   2. 利用二叉排序树，既可以保证数据的检索速度，又可以保证插入、删除、修改的速度

### 二叉树

#### 定义

1. 二叉树每个节点最多只有两棵子树
2. 二叉树的子树有左右之分，次序不能颠倒
3. 第 i 层至多有2 的（ i-1)次方个节点
4. 深度为k的二叉树，至多有2 的k次方 -1 个节点
5. 对任意二叉树，如果终端节点数为N0，度为2的节点数为N2，则N0=N2+1

---

#### 遍历

1. 前序遍历
   1. 父节点、左子树、右子树
   2. 左子树里面：父节点、左子树、右子树   递归下去
   3. 下面两种方式类似
   4. 遍历思路：三种遍历方式，最初都会访问根节点，只是根节点的输出顺序不同
      1. 输出根节点
      2. 左子节点不为空，递归进行前序遍历
      3. 右子节点不为空，递归进行前序遍历
2. 中序遍历
   1. 左子树、父节点、右子树
   2. 遍历思路：
      1. 左子树节点不为空，递归进行中序遍历
      2. 输出根节点
      3. 右子节点不为空，递归进行中序遍历
3. 后序遍历
   1. 左子树、右子树、父节点
   2. 思路
      1. 左子树节点不为空，递归进行中序遍历
      2. 右子树节点不为空，递归进行中序遍历
      3. 最后输出根节点

---

#### 查找

按照指定的节点查找

1. 前序
   1. 判断当前节点是否等于要查找的
   2. 相当则返回当前节点
   3. 不相等，则递归判断当前节点的左子节点
   4. 如果左递归找到则返回，否则，继续递归判断右子节点
2. 中序
   1. 类似同上
3. 后序
   1. 类似同上

---

#### 二叉树删除

1. 删除叶子节点，直接删除该节点
2. 非叶子节点，暂时删除其子树（正常情况是不对的）
3. 非叶子节点，考虑子节点提升的位置

思路：因为二叉树是单向的，所以判断的是当前节点的子节点是否需要删除，而不能去判断当前这个节点是不是需要删除

---

#### 顺序存储二叉树

特点

1. 满足完全二叉树
2. 第n个元素的左子节点为2*n+1
3. 第n个元素的右子节点为2*n+2
4. 第n个元素的父节点为（n-1）/2
5. n表示：二叉树的第几个元素  n从0开始
6. 按照 完全二叉树的层序 顺序存储

例子

数组arr[1,2,3,4,5,6,7]

二叉树 前序去遍历这个数组 1245367

---

#### 线索化二叉树

1. n个节点的二叉链表中，含有n+1（2n-(n-1)）个空指针域
2. 利用空指针域，存放指向该节点在某种遍历次序下的前驱和后继节点的指针，这种附加的指针称为线索
3. 这种加上线索的二叉链表称为线索链表，相应的二叉树称为：线索二叉树
4. 根据线索性质不同，线索二叉树可分为：前序、中序、后序线索二叉树
5. 一个节点前一个节点，称为前驱节点
6. 一个节点的后一个节点，称为后继节点

---



#### 满二叉树

1. 除最后一层无任何子节点外，每一层的所有节点都有两个子节点

   

#### 完全二叉树

1. 设二叉树的深度为h，除h层外，其他层的节点数达到最大数，第h层所有的节点都连续集中在左边

### 二叉查找树/二叉搜索树/二叉排序树

二叉查找树或是一颗空树，或是具有以下性质：

1. 若左子树不空，则左子树上的所有节点的值都小于它的根节点的值
2. 若右子树不空，则右子树上的所有节点的值都大于或等于他的根节点的值
3. 左、右子树也分别为二叉查找树
4. 没有键值相等的树

性质：对二叉查找树进行中序遍历，可得到有序的序列

时间复杂度：和二分查找一样，插入和查找的时间复杂的O(logn)，但在最坏的情况下，仍然会有O(n)的时间复杂度

插入过程：

	1. 若当前二叉查找树为空，则插入的元素为root节点
	2. 若插入的元素小于根节点，则将元素插入左子树中
	3. 若插入的元素大于根节点，则将元素插入右子树中

### 平衡二叉树 / AVL树  

二叉搜索树有可能退化为近似链或链，此时操作的时间复杂度会从O(logn)退化为线性的O(n)

1. 不同意AVL算法

2. 性质：要么为空，要么为：

   - 左右两个子树的高度差的绝对值不超过1
   - 左右两个子树也是一颗平衡二叉树

3. 二叉树常用算法：红黑树、AVL树

4. 最小二叉平衡树的节点公式
   F(n)=F(n-1)+F(n-2)+1

   类似与一个递归数列：斐波那契数列

   1是根节点，F(n-1)是左子树节点数量，F(n-2)是右子树节点数量

### B树

1. 一种用于查找的平衡树，但是不是二叉树，就是平衡多路查找树
2. 能够用来存储排序后的数据

#### 性质

1. B树的阶：子节点数目的最大值
2. 每个节点中，包含数据的关键字key、数据Data、指向子节点的指针
3. 

---

### B+树

1. B树上做的优化
2. InnoDB存储引擎用B+树，实现的索引
3. 所有数据记录在叶子节点上，其数值是按照大小顺序存放在同一层的叶子节点上，非叶子节点只存放key值信息，这样大大加大每个节点存储key的数量，降低了B+tree 的高度
4. 所有叶子节点之间有一个链指针

#### 索引

##### Mysql

###### 索引分类

1. 照数据的存储方式分类
   - 聚集索引
     - 存放的物理顺序和列中的顺序一样，一般设置主键索引就为聚集索引
     - 一个表只能有一个聚集索引，因为主键的作用就是把表的数据格式转换为索引的格式存放
     - 例如select * from xx where id="12":根据索引定位到12所在的叶节点，然后通过叶节点获取id=12的数据行
   - 非聚集索引
     - 例如：User表中的name字段加上索引
     - 和聚集索引一样，同样是采用平衡多路查找树作为索引的数据结构，索引树结构中各节点的值来自表中的索引字段。例如：User表中的name字段加上索引。那么索引就是由name字段中的值构成的
     - 通过非聚集索引第一次只能查到记录对应的主键，然后再通过主键的值进行聚集索引找到需要的数据
     - 每次给字段建一个新索引，字段中的数据就会被复制一份出来，用于生成索引。每个索引互相不存在关联**
   - 两个索引的区别：聚集索引一张表只能有一个，然而非聚集索引一张表 可以有多个
2. 应用层次
   - 单列索引
     - 主键索引
     - 普通索引
     - 唯一索引
       - 和普通索引基本类似，不过唯一索引所在列的值必须唯一，可以为null值。
   - 组合索引
     - 多个字段上创建的索引
     - 使用组合索引时，遵循最左前缀集合
     - 例如：index (a,b,c) 那么 索引支持a | a、b | abc 这三种组合进行查找，但是不支持b | c | b、c 这样的查找，必须按照索引字段创建的顺序来
   - 全文索引  fulltext
     - 通过关键字的匹配来进行查询过滤=》基于相似度的查询
3. 存储结构
   - B树索引
   - B+树索引
   - Hash索引
   - 等

索引定位数据：查询到B+树叶子节点后，遍历叶子节点的数据页，从而找出该条记录

---

### B*树

B+树的变体，在B+树的非根节点和非叶子节点中再添加指向兄弟的指针

### 2-3树

---

### 堆排序

堆排序是一种**选择排序**，它的最好、最坏、平均时间复杂度均为O(nlogn)，它是不稳定排序

堆：具有以下性质的**完全二叉树**：

每个节点的值都大于或等于其左右孩子的值，称为**大顶堆**。注意：没有要求节点的左孩子和右孩子的值的大小关系。

每个节点的值小于或等于其左右孩子节点的值，称为**小顶堆**

一般：**升序采用大顶堆、降序采用小顶堆**

#### 堆排序思想

1. 将待排序序列构造成一个大顶堆 （构建成一个数组，树按照数组形式存储）

   - 使用数组存储二叉树时，若某个**非叶子节点**存储在下标为i的位置，其左右孩子节点分别存储在下标为2i+1和2i+2的位置

2. 此时，整个序列的最大值就是堆顶的根节点

3. 将最大值与末尾元素进行交换，此时数组末尾就是最大值

4. 然后，将剩余的n-1个元素重新构造成一个堆，这样会得到n个元素里面的次小值。

5. loop 1、2、3，便能得到一个有序序列

6. ~~~text
   例子：4，6，8，5，9使用堆排序，升序排序
   图结构为层序排序 
   4->left 6
   4->right 8
   6->left 5 
   6->right 9
   arr[4,6,8,5,9]
   ~~~

   

---

### 赫夫曼树

1. 给定N个权值作为**N个叶子节点**，构造一棵二叉树，若该树的带权路径长度(wpl)达到最小，称这样的树为**最优二叉树**，也称：赫夫曼树
2. 赫夫曼树是带权路径长度最短的树，权值较大的节点离根节点较近
3. 路径：一棵树中，从一个节点往下可以达到孩子或孙子节点之间的通路
4. 路径的长度：
   1. 通路中分支的数目称为路径长度。
   2. **树根到树中每一结点的路径长度之和**
   3. 若根节点的层数为1，从根节点到第L层节点的路径长度为L-1
5. 节点的权：赋予树中节点一个有着某种含义的数值，这个数值称为该节点的权
6. 节点带权路径长度：从根节点到该节点之间的路径长度与该节点的权的乘积
7. 树的带权路径长度：所有叶子节点的带权路径长度之和 wpl，权值越大的节点，离根节点越近的二叉树才是最优二叉树

构造赫夫曼树 步骤

1. 将每个数据从小到大进行排序，每个数据都代表一个节点，每个节点可以看出左右子树为空的二叉树
2. 取出根节点权值最小的两颗二叉树
3. 组成一颗新的二叉树，新的二叉树的根节点的权值是前面两颗二叉树根节点权值的和
4. **再将这颗二叉树，以根节点的权值大小再次排序**，不断重复1234，知道所有节点都被处理完成
5. 此时得到一个赫夫曼树

---

### 赫夫曼编码

1. 一种编码方式，属于一种程序算法
2. 广泛应用于电讯通信中、数据文件压缩。其压缩率通常在20%-90%之间
3. 赫夫曼码是可变编码（VLC）的一种，称为最佳编码
4. 前缀编码：字符的编码不能是其他字符编码的前缀，即：不能匹配到重复的编码

---



































