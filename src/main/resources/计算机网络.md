## 计算机网络

https://www.nowcoder.com/discuss/947631?type=all&order=recall&pos=&page=1&ncTraceId=&channel=-1&source_id=search_all_nctrack&gio_id=DC793D7EB38CB077052581688EF16D7A-1653143551547



https://www.nowcoder.com/discuss/954007?channel=-1&source_id=discuss_terminal_discuss_history_nctrack&ncTraceId=2480f0509425414883ded06fc4e9fb68.273.16531435821209374

### OSI、TCP/IP

|      | OSI七层模型 | TCP/IP四层 (或5层)模型                         | 常用协议                            |
| ---- | ----------- | ---------------------------------------------- | ----------------------------------- |
|      | 应用层      | 应用层                                         | Http、Https、ftp、dns、smtp、telnet |
|      | 会话层      |                                                |                                     |
|      | 表示层      |                                                |                                     |
|      | 传输层      | 传输层                                         | TCP、UDP                            |
|      | 网络层      | 网络层                                         | IP、ICMP、RIP、IGMP、OSPF           |
|      | 数据链路层  | 数据链路层      （底两层可以统称为数据链路层） | 以太网、令牌环、PPP、ARP、RARP      |
|      | 物理层      | 物理层                                         | 物理线路、光纤、无线电等            |



区别

1. TCP/IP是一个协议簇，OSI是一个模型
2. TCP/IP是由一些交互性的模块做成的分层次的协议，其中每个模块提供特定的功能。OSI则指定了哪个功能是属于哪一层
3. TCP/IP是OSI的简化版，目前已经成为了国际标准

---



### TCP/UDP区别

|                  | UDP                                  | TCP                                      |
| ---------------- | ------------------------------------ | ---------------------------------------- |
| 是否连接         | 无连接                               | 面向连接                                 |
| 是否可靠         | 不可靠传输，不使用流量控制和拥塞控制 | 可靠传输，使用                           |
| 连接对象个数     | 支持一对一、一对多、多对多           | 只能一对一                               |
| 传输方式         | 面向报文                             | 面向字节流                               |
| 首部开销         | 首部开销小，仅8字节                  | 首部最小20字节，最大60字节               |
| 使用场景         | 实时应用(视频会议、直播、QQ等)       | 适用于要求可靠传输的应用，例如文件传输等 |
| 对系统的资源要求 | 较少                                 | 较多                                     |

·	

---



### TCP如何实现数据的可靠性

一句话总结：通过校验和、序列号、确认应答、超时重传、连接管理、流量控制、拥塞控制等机制来保证可靠性



---

### Tcp滑动窗口

Tcp会将较大的数据拆分成一个个小的数据包再进行发送，发送完一个包等待ACK，这种模式简单但是比较慢、吞吐量低。所以我们在等待ACK的同时，可以继续发送接下来的数据包。

滑动窗口就是在发送完一个数据包后，不需要等待ACK消息返回，可以发送后面的数据包，从而解决吞吐量问题

发送方和接收方各有一个窗口，接收方通过TCP报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其他信息设置自己的窗口大小

![image-20220523203008321](https://pic-typora-qc.oss-cn-chengdu.aliyuncs.com/network_img/202205232030465.png)



#### 窗口

发送方的发送缓存内的数据，可以分为4类

1. 已发送，已收到ACK
2. 以发送，未收到ACK
3. 未发送，但允许发送
4. 未发送，但不允许发送

其中类型2、3属于发送窗口

接收方的缓存数据分为3类

1. 已接收
2. 未接收，准备接收
3. 未接收，未准备接收

其中类型2属于接收窗口

![image-20220523203430128](https://pic-typora-qc.oss-cn-chengdu.aliyuncs.com/network_img/202205232034302.png)



Tcp header(首部)中有一个Window size字段，它其实是指接收端的窗口，即接收窗口。用来告知发送端自己所能接收的数据量，从而达到一部分流控的目的



#### 滑动机制

发送窗口只有收到发送窗口内字节的ACK确认，才会移动发送窗口的左边界

接收窗口只有在前面所以的段都确认的情况下才会移动左边界。当前面还有字节未接收但收到后面字节的情况下，窗口不会移动，并不对后续字节确认。以此确保发送端会对这些数据重传

遵循快速重传、累计确认、选择确认等规则

---

### 拥塞控制

防止发送方发的太快，使得网络来不及处理，从而导致网络拥塞

如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。因此当出现拥塞时，应当控制发送方的速率。这一点和流量控制很像，但是出发点不同。流量控制是为了让接收方能来得及接收，而拥塞控制是为了降低整个网络的拥塞程度

![image-20220523204159945](https://pic-typora-qc.oss-cn-chengdu.aliyuncs.com/network_img/202205232042058.png)



拥塞控制的方法主要有4种：

1. 慢启动：不要一开始就发送大量的数据，由小到大逐渐增加拥塞窗口的大小
2. 拥塞避免
   - 拥塞避免算法让拥塞窗口缓慢增长，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd+1，而不是加倍，这样拥塞窗口按照线性规律缓慢增长
   - 
3. 快重传：
4. 快恢复：

---

### TCP三次握手四次挥手

TCP是面向连接的、可靠的字节流服务，但是在网络中的传输单位却是报文段的格式，一个Tcp报文段分为首部和数据两部分，而协议的全部实现都在TCP报文段的首部体现出来的

TCP使用校验和、确认和重传机制保证可靠传输

![image-20220522220318423](https://pic-typora-qc.oss-cn-chengdu.aliyuncs.com/network_img/202205222203646.png)



#### 各字段含义

1. 序号字段Seq：值的是本tcp报文段所发送的数据的第一个字节的序号
2. 确认号字段ack：期望收到对方的下一个报文段的数据的第一个字节的序号。若确认号为N，则表明到序号N-1为止的所有数据都已经正确收到
   - 确认位ACK：只有ack=1时，确认号字段才有效，ack=0时确认号无效。Tcp规定在建立连接后所有传送的报文段必须把ack置1
   - 同步位SYN：同步syn=1表示这是一个连接请求或连接接收报文。当ACK=0、syn=1表示这个一个连接请求报文，对方若同意建立连接，则在响应报文中使用ack=1、syn=1
   - 终止位Fin：用来释放一个连接，FIN=1表示此报文段的发送方的数据已经发送完毕了，并要求释放TCP连接
   - 紧急URG：urg=1表明该报文段有紧急数据，应尽快发送
   - 推送PSH：接收防守到psh=1的报文段时，会尽快交付接收应用进程，不再等待整个缓存填满再交付。实际使用较少
   - 复位RST：rst=1时，表明tcp连接中出现严重差错，必须断开连接再重连

#### 三次握手

![image-20220522221807088](https://pic-typora-qc.oss-cn-chengdu.aliyuncs.com/network_img/202205222218182.png)

1. 第一次握手：客户端将标志位syn置为1，随机产生一个序列号值seq=x，并将该数据包发送给服务端，客户端进入syn_send状态，等待服务端确认
2. 第二次握手：服务端收到数据包后，由Syn=1标志位知道这是客户端请求建立连接，服务端返回确认包(ACK)应答，同时还有发送一个SYN包回去。将标志位SYN、ACK都置1，ack=x+1(表示确认客户端发送来的seq=x的都收到了)，产生seq=y（表示让客户端确认能否收到)，并将该数据包发送给客户端以确认连接请求，发送完后服务端进入SYN-RCVD状态
3. 第三次握手：客户端收到确认后检查，如果正确则将标志位ACK置1，ack=y+1，并将该数据包发送给服务端，服务端进行检查如果正确则连接建立成功，客户端和服务端进入estab-lished状态，完成三次握手，随后客户端和服务端之间就可以传输数据



**问题1**：为什么需要三次握手？最后一次没有行不行？会有什么问题？

TCP连接因为是全双工的，发送消息的两个方向的连接都需要建立成功，若要保证双向连接都成功的话，三次通信是最少次数了。大于三次后面的次数通信就没有必要了，纯粹浪费资源

TCP进行可靠传输的关键就在于维护一个序列号，三次握手的过程即是通讯双方告知序列号起始值，并确认对方已经收到了序列号起始值

如果是两次握手，最多只有客户端的的起始值序列号能被确认，但是服务器端的序列号得不到确认。即：服务端发出应答消息后，它不能确认客户端是否接收到消息了，那么这将意味着只有客户端可以向服务端发送数据

**问题2**：三次握手失败了会怎样

1. 若在客户端发送SYN后没有收到服务端的ACK消息，客户端会重传，第一次在5-6s之间，第二次在24s，超过75s后，若还是不成功，则放弃尝试
2. 若服务端没有收到最后一次ACK消息，同样的原理，Server会进行重传第二步的SYN、ACK消息

**问题3**：三次握手阶段能否携带数据

第三次可以携带数据。

假如第一次握手可以携带数据的话，如果恶意攻击服务器，每次都在第一次握手中的SYN报文中放入大量数据。而且频繁重复发SYN报文，服务器会花费很多的时间和内存空间去接收这些报文。 

 第三次握手，此时客户端已经处于ESTABLISHED状态。对于客户端来说，他已经建立起连接了，并且已经知道服务器的接收和发送能力是正常的。所以也就可以携带数据了

**问题4**：三次握手阶段，最后一次ACK包丢失，会发生什么？

1. 服务端：此时服务端TCP连接状态为SYN-RECV，会根据TCP的超时重传机制，会等3、6、12秒后重新发送SYN、ACK包，以便客户端重新发送ACK包。若重试次数达到指定次数后，仍未收到客户端的ACK应答，那么一段时间后服务端字段关闭这个连接
2. 客户端：因为发出ACK包，但是不知道丢失了，所有客户端会认为这个连接已经建立，如果客户端向服务端发送数据，服务端将以RST包进行相应。此时，客户端知道第三次握手失败



#### 四次挥手

![image-20220522232606134](https://pic-typora-qc.oss-cn-chengdu.aliyuncs.com/network_img/202205222326308.png)



1. 第一次挥手：客户端发送FIN=1，用来关闭客户端到服务端的数据传输，发送完成后，客户端进入FIN-wait状态
2. 第二次挥手：服务端收到FIN后，发送一个ACK给客户端，确认序号为收到的seq+1，服务端进入Close-wait状态。次数TCP连接处于半关闭状态，即：客户端已经没有要发送的数据了，但是服务端若向客户端发送数据，客户端仍要接收
3. 第三次挥手：服务端发送一个FIN，用来关闭服务端到客户端的数据传输，服务端进入Last-ack状态
4. 第四次挥手：客户端收到FIN后，客户端进入Time-wait状态，接着发送一个ACK给客户端，确认后，服务端进入Close状态，完成四次挥手，TCP连接断开



问题1：四次挥手中为什么释放连接时需要等2msl

MSL：报文最大生存事件，设置2msl可以保证上一次连接的报文已经在网络中消失，不会出现与新TCP连接报文冲突的情况



问题2：为什么需要四次挥手

主要原因：当服务端收到客户端FIN数据包后，服务端可能还有数据没发完，不会立即close

所以服务端会先将 ACK 发过去告诉客户端我收到你的断开请求了，但请再给我一点时间，这段时间用来发送剩下的数据报文，发完之后再将 FIN 包发给客户端表示现在可以断了。之后客户端需要收到 FIN 包后发送 ACK 确认断开信息给服务端

---

### TCP半连接队列和全连接队列

![image-20220523094903453](https://pic-typora-qc.oss-cn-chengdu.aliyuncs.com/network_img/image-20220523094903453.png)



---

### 粘包/拆包

Tcp发生数据时会根据TCP缓冲区的实际情况进行包的划分，一个完整的包可能会被Tcp拆分成多个包进行发送，也可能把多个小的包封装成一个大的数据包发送，这就是Tcp粘包和拆包问题

![image-20220523201855139](https://pic-typora-qc.oss-cn-chengdu.aliyuncs.com/network_img/202205232019726.png)



TCP发送粘包的原因？

1. 发送的数据小于Tcp缓冲区大小，tcp将缓冲区的数据一次发出去可能就会发生粘包
2. 接收数据端的应用层没有及时读取接收缓冲区的数据，将发生粘包

发生TCP拆包的原因？

1. 待发送数据大于最大报文长度，tcp在传输前将进行拆包
2. 发送的数据大于tcp发送缓冲区剩余空间大小，将会发生拆包

解决方案

1. 发送端给每个数据包添加首部，首部中包含数据包的长度，这样接收端在接收到数据后，通过该字段就可以知道每个数据包的实际长度了
2. 发送端将每个包设置固定长度，这样接收端每次从读取固定长度的数据把每个数据包拆分开
3. 可以在数据包之间设置边界，如：添加特殊符号，接收端可以通过这个特殊符号来拆分包

---



### DNS协议

DNS协议是基于UDP的应用层协议，它的功能是根据用户输入的域名，解析出该域名对应的IP地址，从而给客户端进行访问

#### DNS解析过程

1. 用户在浏览器输入www.baidu.com域名后，操作系统会先检查自己本地的hosts文件是否有这个网址的映射关系，如果有就先调用这个IP地址映射，完成域名解析
2. 如果hosts里面没有这个域名的映射关系，则查找本地DNS解析器缓存中是否有这个网址的映射关系，如果有则直接返回，完成域名解析
3. 若hosts与本地DNS解析器缓存都没有相应的网址映射关系，则首先会查找TCP/IP参数中设置的首先DNS服务器，称之它为本地DNS服务器，此服务器收到查询请求时，如果要查询的域名包含在本地配置区域资源中，则返回解析结果给客户端，完成域名解析，此解析具有权威性
4. 若要查询的域名，不是由本地DNS服务器区域解析，但该服务器已缓存了此网址的映射关系，则调用这个IP地址映射，完成域名解析，此解析不具有权威性
5. 如果本地DNS服务器区域解析文件与缓存解析都失败，则根据DNS服务器的设置(是否设置转发器)进行查询，如果未设置转发模式，本地DNS就把请求发送至13台根DNS，根DNS服务器收到请求后会判断这个域名(.com)是谁来授权管理，并会返回一个负责该顶级域名服务器的一个IP。本地DNS服务器收到IP信息后，将会联系负责.com域的这个服务器。这台负责.com域的服务器收到请求后，如果自己无法解析，它就会找一个管理.com域的下一级DNS服务器地址(baidu.com)给本地DNS服务器。当本地DNS服务器收到这个地址后，就会查找baidu.com域服务器，重复上面的动作，进行查询，直到找到www.baidu.com主机
6. 如果设置了转发模式，此DNS服务器就会把请求转发至上一级服务器，由上一级服务器进行解析，上一级服务器如果不能解析，或找根DNS或把请求转至上上级，依次循环。不管是本地DNS服务器转发，还是根DNS，最后都会把结果返回给本地DNS服务器，由此DNS服务器再返回给客户端

#### 浏览器输入www.baidu.com后的执行过程

域名解析->建立TCP连接->发起http请求->服务器响应http请求，浏览器得到html代码->浏览器解析html代码，并请求html代码中的资源(js、css、图片等等)->浏览器对页面进行渲染呈现给用户

---



### IP地址分类

 IP地址由两部分组成，即网络地址和主机地址。网络地址表示其属于互联网的哪一个网络，主机地址表示其属于该网络中的哪一台主机

![image-20220521232341510](https://pic-typora-qc.oss-cn-chengdu.aliyuncs.com/network_img/202205212323568.png)

A类：（1.0.0.0 ——126.0.0.0）一般用于大型网络

B类：（128.0.0.0-191.255.0.0）

C类：（192.0.0.0-223.255.255.0)

D类：是多播地址，地址的网络号取值为224~239，一般用于多路广播用户

E类：保留地址，地址的网络号取值为240~255



---

### HTTP协议

http协议是超文本传输协议，它是基于TCP协议的应用层协议，即客户端和服务器进行数据传输的一种规则。该协议是一种无状态的协议

#### 转发和重定向的区别

转发：是服务器的行为。服务器直接向目标地址访问URL，将相应的内容读取之后发给客户端浏览器，用户浏览器地址栏Url不变，转发页面和转发到的页面可以共享request里面的数据

重定向：利用服务器返回的状态码实现的，如果服务器返回301、302，浏览器收到消息后自动跳转到新的网址重新请求资源。用户的地址栏Url会发生改变，而且不能共享数据



#### http中header常见字段

请求头：

1. Accept：浏览器可以接收的类型：text/html，image/* 
2. Accept-Charset：浏览器可以接收的编码类型
3. Accept-Encoding：浏览器可以接收压缩编码类型：gzip、compress
4. Accepet-Language：浏览器可以接收的语言和国家类型 en-us、zh-cn
5. Host：浏览器请求的主机和端口
6. User-Agent：浏览器相关信息
7. Cookie
8. Connection：http请求的版本的特点

响应头：

1. Content-Type：服务器发送内容的类型和编码类型
2. Cache-Control：服务器控制浏览器是否缓存页面



#### Http1.0、Http1.1

http1.0

1. 规定了请求头和请求尾，响应头和响应尾
2. 每一个请求都是一个单独的连接，做不到连接的复用

http1.1

1. 默认开启长连接，在一个TCP连接上可以发送多个http请求和响应。使用TCP长连接的方式改善了1.0短链接造成的性能开销
2. 支持管道网络传输，只有第一个请求发出去了，不必等待其返回就可以发送第二个请求出去，可以减少整体的响应事件
3. 服务端无法主动push



#### Http长连接与短链接

长连接、短连接都是指Http底层Tcp的连接

短连接：客户端与服务器进行一次HTTP连接操作，就进行一次TCP连接，连接结束后，TCP关闭连接。 

 长连接：如果HTTP头部带有参数[keep]()-alive，即开启长连接，网页完成打开后，底层用于传输数据的TCP连接不会直接关闭，会根据服务器设置的保持时间保持连接，保持时间过后连接关闭



#### Http2.0的改进

提出多路复用。多路复用前，文件是串行传输的，请求a文件，b文件只能等待，并且连接数过多。引入多路复用，a文件b文件可以同时传输。 

 引入了二进制数据帧。其中帧对数据进行顺序标识，有了序列id，服务器就可以进行并行传输数据



#### http与https的区别

http所有的内容都是明文，并且客户端和服务器端都无法验证对方的身份

https具有安全性的ssl加密传输协议，加密采用对称加密，https协议需要到ca申请证书，一般免费的证书很少，需要缴费



#### Tls/ssl、http、https直接的关系

SSL：Secure Sockets Layer 即安全套接层，其继任为TLSTransport Layer Security传输层安全协议，均用于在传输层为数据通讯提供安全支持

可以将https理解为http协议+TLS/SSL



#### https连接过程



#### get/post区别

get：指定资源请求数据，get请求的数据会附加到url中，传输数据的大小受url的限制

post：向指定资源提交要被处理的数据，post在发送数据前将请求头发给服务器进行确认，然后才真正发送数据

GET：请求的长度受限于浏览器或服务器对URL长度的限制，允许发送的数据量比较小，而POST请求则是没有大小限制的。 

 POST：安全性要比 GET 的安全性高，因为 GET 请求提交的数据将明文出现在 URL 上，而 POST 请求参数则被包装到请求体中，相对更安全



---

### 网络安全

#### 什么是XSS攻击

XSS：Cross Site Scripting，即跨站脚本攻击，xss的重点不在于跨点而在于脚本的执行

xss原理：恶意攻击者在web页面中会插入一些恶意的script代码。当用户浏览该页面的时候，那么嵌入到web页面中的script脚本会执行，因此达到恶意攻击用户的目的

xss攻击主要有以下分类：反射型、存储型、Dom-based型。反射型和dom-based可以归为非持久性xss攻击。存储型可以归类为持久性xss攻击



#### 什么是CSRF

Cross Site Request Forgery，即跨站域请求伪造，是一种网络攻击方式，通常缩写为CSRF或者XSRF，是一种对网站的恶意利用

它与XSS不同，并且攻击方式几乎相左

xss是利用站点内的信任用户，而CSRF是通过伪装来自受信任用户的请求，来利用受信任的网站。与xss相比，csrf攻击往往难以防范，所有被认为比xss更具危险性







