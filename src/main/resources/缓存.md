## 缓存

### 命中率

#### 命中率=命中数/(命中数+没有命中数)

影响缓存名字率的因素：

1. 业务场景和需求
   - 缓存通常适用于读多写少的场景，反之的使用意义不大，命中率会很低。
   - 业务需求也决定了实时性的要求，实时性要求越低越适合缓存
2. 缓存的设计(策略和粒度)
   - 通常缓存的粒度越小，命中率越高
   - 例如：缓存一个用户信息的对象，则只有当这个用户的信息发生变化时才更新缓存，而如果是缓存一个集合的话，集合中任何一个对象发生变化都要重新更新缓存
3. 缓存的容量和基础设施
   - 缓存的容量有限，就会引起缓存的失效和被淘汰。目前大多数中间件都采用LRU这个算法
   - 同时，缓存的技术选型也是至关重要的，比如：采用本地内置的应用缓存就比较容易出现单机瓶颈，而采用分布式缓存就更加容易扩展

#### 最大空间

缓存最大空间一旦缓存中的元素数量超过这个值，那么将会触发缓存启动清空策略，根据不同的场景合理的设置最大元素往往可以一定程度上提高缓存的命中



---

### 缓存介质

从硬件介质上看无非就是内存和硬盘两种，但从技术上看，可分为内存、硬盘文件、数据库

1. 内存
   - 将缓存存储与内存中是最快的，无需额外的I/O开销，但是内存的缺点就是没有持久化到磁盘，一旦应用异常宕机而重新启动后，数据无法复原
2. 硬盘
   - 一般来说，很多缓存框架会结合内存和硬盘，在内存分配空间满了或是异常情况下，可以主动或被动的将内存空间数据持久化到硬盘，达到释放空间或备份数据的目的
3. 特殊数据库
   - 例如：redis



---

### 缓存淘汰算法

FIFO、LFU、LRU、过期时间、随机

1. FIFO：最先进入缓存的数据，在缓存空间不足时被清除，为了保证最新数据可用，保证实时性
2. LFU(Least Frequently Used)：最近最不常用，基于访问次数，去除命中次数最少的元素，保证高频数据有效性
3. **LRU**(Least Recently Used)：最近最少使用，基于访问时间，在被访问过的元素中去除最久未使用的元素，保证热点数据的有效性



---

### 缓存应用和实现

应用服务中，常见缓存有本地缓存、分布式缓存

#### 本地缓存

指的是：应用程序中的缓存组件，其最大的优点是应用和缓存是在同一个进程内部，请求缓存非常快，没有其他的开销

适用场景：单应用不需要集群支持或集群情况下各节点无需互相通知的场景下

缺点：缓存与应用程序耦合，多个应用程序无法共享缓存，各应用或集群各节点需要维护自己的单点缓存，对内存是一种浪费

#### 分布式缓存

指：应用分离的缓存组件或服务，最大优点是自身就是一个独立的应用，与本地应用隔离，多个应用可直接共享内存



目前各种类型的缓存都活跃在成千上万的应用服务中，还没有一种缓存方案可以解决一切的业务场景或数据类型，我们需要根据自身的特殊场景和背景，选择最适合的缓存方案



#### 分布式缓存实现方案

##### memcached缓存

##### redis缓存

---



### Ehcache

### Guava Cache

google开源的Java重用工具库Guava里面的一款缓存工具

### Spring注解缓存

和spring的事务管理类似，关键原理就是Spring Aop，通过Aop实现了在方法调用前、后获取方法的入参和返回值，进而实现了缓存的逻辑。利用aop的动态代理技术，当客户端尝试调用pojo的foo()方法的时候，给它的不是pojo自身的引用，而是一个动态生成的代理类



常用注解：主要针对方法上注解使用，部分场景也可以直接类上注解使用，当在类上使用时，该类所有方法都将受影响

| 标签类型    | 作用                                                         | 主要配置参数说明                                             |
| ----------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| @Cacheable  | 主要针对方法配置，能够根据方法的请求参数**对其结果进行缓存** | value：缓存的名称，在 Spring 配置文件中定义，必须指定至少一个； key：缓存的 key，可以为空，如果指定要按照 SpEL 表达式编写，如果不指定，则默认按照方法的所有参数进行组合； condition：缓存的条件，可以为空，使用 SpEL 编写，返回 true 或者 false，只有为 true 才进行缓存 |
| @CachePut   | 主要针对方法配置，能够根据方法的请求参数对其结果进行缓存，和 @Cacheable 不同的是，它每次都会触发真实方法的调用 | value：缓存的名称，在 spring 配置文件中定义，必须指定至少一个; key：缓存的 key，可以为空，如果指定要按照 SpEL 表达式编写，如果不指定，则默认按照方法的所有参数进行组合； condition：缓存的条件，可以为空，使用 SpEL 编写，返回 true 或者 false，只有为 true 才进行缓存 |
| @CacheEvict | 主要针对方法配置，能够根据一定的条件对缓存进行清空           | value：缓存的名称，在 Spring 配置文件中定义，必须指定至少一个； key：缓存的 key，可以为空，如果指定要按照 SpEL 表达式编写，如果不指定，则默认按照方法的所有参数进行组合； condition：缓存的条件，可以为空，使用 SpEL 编写，返回 true 或者 false，只有为 true 才进行缓存； allEntries：是否清空所有缓存内容，默认为 false，如果指定为 true，则方法调用后将立即清空所有缓存； beforeInvocation：是否在方法执行前就清空，默认为 false，如果指定为 true，则在方法还没有执行的时候就清空缓存，默认情况下，如果方法执行抛出异常，则不会清空缓存 |



#### Spring注解缓存扩展

即：基于Spring注解，自定义缓存注解

利用Spring提供的扩展点实现我们自己的缓存，在不改变原有的代码情况下进行扩展

1. 实现CacheManager接口，管理自身的cache实例
2. 实现自己的cache实例MyCache（继承自Cache），
3. 对配置项进行声明，将MyCache实例注入CacheManager进行同一管理









