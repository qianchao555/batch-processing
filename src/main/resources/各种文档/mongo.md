# Mongo

MongoDB是==面向文档==的NoSQL数据库，用于大量数据存储

## 主要功能

1. 每个数据库都包含集合，集合有包含文档
   - 每个文档可以具有不同数量的字段
   - 每个文档的大小和内容可以互不相同
2. MongoDB的行不需要预先定义结构，相反，可以动态创建字段



## MongoDB架构的关键组件

1. _id：这是每个mongoDB文档的必填字段，表示mongoDB文档中的唯一值
   - 文档必须包含一个`_id`字段，可以是任意类型的，默认是ObjectId对象
   - 类似于主键，创建新文档时，如果没有_id字段，会自动创建该字段
   - ObjectId是一个12字节Bson类型数据
     - 前4个字节：表示时间戳
     - 紧接着的3字节：机器标识码
     - 剩下3字节：随机数
2. 集合：这是mongoDB中，文档的分组
   - 等效于：关系型数据库中的表
   - 集合存在于单个数据库中
3. 游标：指向查询结果集的指针
4. 数据库：集合的容器，类似于关系型数据库的某个库
5. 文档：mongoDB集合中的记录，称为文档
   - 类似于关系型数据库的某条记录
   - 文档包含字段名和值
6. 字段：文档中的key/value对，一个文档可以具有0个或多个字段
7. Json：可读性高，用于表示结构化数据的纯文本格式





## 为什么需要MongoDB

1. 面向文档的，将数据存储在文档中，使得mongoDB非常灵活，可以适应实际的业务环境和需求
2. 临时查询
   - MongoDB支持按照字段、范围、正则表达式搜索，可以查询返回文档中的特定字段
3. 索引
   - 可以创建索引，以提高mongoDB的搜索性能
   - 文档中的任何字段都可以建立索引
4. 复制：提供了副本集的高可用
5. 负载均衡
   - 使用分片的功能，实现水平扩展





## mongoDB的数据建模

mongo的数据具有灵活的架构，不会强制执行文档结构，使得mongo具有很强的灵活性

在mongo中，对数据建模时，应注意以下几点

1. 应用程序的需求是什么
   - 基于需求确定文档的结构
2. 数据检索模式
   - 例如：使用大量的查询操作，那么考虑在数据模型中使用索引来提高查询效率
3. 数据库是否频繁发生crud操作
   - 如果数据建模设计需要重新考虑使用索引或合并分片，以提高整体mongo环境的效率



## mongoDB创建数据库和集合

- 使用“use”命令创建数据库
- 使用insert()创建集合
- 使用insert()添加文档
- find()查询文档
- sort、limit、orders字句类似sql语句的作用
- 学习的时，看api就可以了



## mongoDB安全、监控、备份

安全

1. 启用访问控制
2. 配置基于角色的访问控制
3. 尝试将mongoDB配置为某种加密协议
4. 配置审计
5. 使用单独的用户ID运行mongoDB服务器实例



mongoDB备份程序：mongodump

1. 通过复制底层数据文件进行备份
2. 使用mongodump备份数据库
3. mongoDB cloud manager备份





## 数据库和集合

一个MongoDB实例，可以创建多个数据库，一个库可以创建多个集合，一个集合由多个文档组成

MongoDB内建的库

- admin库：主要存放有数据库账户相关信息
- config库：用于分片集群环境，存放分片相关的元数据信息
- local库：该库永远不会被复制到从节点，可以用来存放限于本地单台服务器的任意集合副本集的配置信息、oplog就存储再local库





### Collection

> MongoDB将Bson文档(即数据记录)，存储在集合Collection中，集合相当于关系型表
>
> 集合不存在时，在第一次存储数据到该集合时，Mongo会自动创建该集合



#### 文档

- 文档验证
  - 默认情况下，集合不要求其文档具有相同的模式，也就是说，单个集合的文档，不需要具有相同的字段集，且字段的数据类型在集合的不同文档之间可以不
  - 但是，从Mongo3.2开始，可以在更新和插入操作期间，对集合强制执行`文档验证规则`
- 修改文档结构
  - 可以动态更改集合中文档的结构。例如：添加新的字段、删除现有字段

#### 唯一标识符

> 集合被分配一个不变的UUID,且副本集的所有成员和分片集群中的分片的集合UUID均相同



#### 视图

> mongo3.4开始，可以基于已存在的集合或者视图传教只读的视图View
>
> 类似于Mysql的视图

- 视图是只读的，通过视图进行写操作会出现错误
- 视图使用其上游集合的索引
  - 索引是基于集合的，所以==不能基于视图==创建索引、删除、重建索引，也不能获取视图的索引列表
  - 也不能指定$natural排序
- 不能重命名视图
- 如果视图依赖的集合是分片的，那么视图也视为分片的
  - 因此，不能指定分片视图中的$lookup的from字段与$graphLookup操作
- 删除视图、修改视图



## 文档

> 文档是MongoDB的基本存储单元，它以一种BSON的文档的结构表示
>
> MongoDB将数据记录存储为BSON结构的文档，BSON,Binary JSON，Json文档的二进制表示形式



文档大小限制：Bson文档的最大大小为16MB

- 防止单个文档过大或在传输过程中占用过多的带宽
- 要存储大于最大大小的文档，Mongo提供了GridFS





## CRUD

### 文本索引

Mongo支持对字符串内容的文本搜索查询，要执行文本搜索查询，必须在集合上有一个文本索引

- 一个集合只能有一个文本索引，但是该索引可以覆盖多个字段





# MongoDB关系

MongoDB的关系表示：多个文档之间在逻辑上的相互联系

文档之间可以通过：嵌入和引用来建立联系

- 嵌入式：把文档嵌入到其中
- 引用式：通过引用文档的`_id`字段来建立关系
  - 引用哪个数据库、哪个集合、哪个文档



Mongo中文档的关系可以是

- 1：1、1：N、N:1、N:N





# MongoDB数据库文件

> MongoDB的数据库文件和其存储引擎有直接的关系

MongoDB提供了3种存储引擎

1. MMAPV1
   - V3.2版本之前采用
   - V4.2中移除了MMAPV1
2. ==WiredTiger==
   - V3.2开始使用
3. In Memory



WiredTiger引擎下的数据库文件

- collection-*.wt文件：存储collection的数据
- index-*.wt：存储索引的数据
- WiredTiger:存储基本配置信息
- WiredTiger.wt：存储所有其他collection的元数据信息
- WiredTiger.lock：存储进程ID,用于防止多个进程连接同一个Wiredtiger数据库
- WiredTiger.turtle：存储WiredTiger.wt的元数据信息
- journal：存储Write ahead log



WiredTiger

> 一个优秀的单机数据库存储引擎

存储引擎要做的事情：无非就是把磁盘上的数据读取到内存返回给应用，或者将应用修改的数据由内存写入到磁盘上去

如何设计一种高效的数据结构和算法是所有存储引擎要考虑的根本问题

目前大多数流行的存储引擎都是**基于**B-Tree、LSM Tree这两种数据结构来设计的

- B-Tree
  - 像Oracle、MySQL(InnoDB)、PostgreSQL、DB2等这些传统的关系型数据库的底层存储引擎都依赖于B-Tree开发的
- LSM(Log Structured Merge)Tree
  - 像ElasticSearch(Lucene)、Google Big Table、Apache HBase、Cassandra等这些当前流行的NoSQL数据库存储引擎是基于LSM Tree开发的
- 插件式：兼容以上2种



MongoDB采用何种方式

> MongoDB也采用了插件式存储引擎架构，底层的WiredTiger存储引擎还支持B-Tree和LSM两种结构组织数据
>
> 但是，MongoDB再使用WiredTiger作为存储引擎时，==目前默认配置是B-Tree结构==

B-Tree：是为磁盘或其他辅助存储设备而设计的一种数据结构，目的是为了在查找数据的过程中，减少磁盘I/O的次数，因为节点就存储了数据







# Mongo事务

Mongo从4.0版本开始，才支持事务，2024-12-29已经是8.x版本了



Mongo中，对单个文档的操作是原子的

对于需要对多个文档（单个或多个集合中）进行原子性读写的场景，Mongo支持多文档事务。使用分布式事务，事务可以跨多个集合、数据库、文档和分片使用



多文档事务（分布式事务）

- 指的是分片集群和副本集群上的多文档事务



# Mongo索引

如果没有索引，mongo必须执行集合扫描，相当于Mysql的全表扫描

MongoDB索引是存储在内存中的

一个查询如果存在适当的索引，那么Mongo可以使用该索引来限制它必须检查的文档数量

Mongo的索引也是一种特殊的==数据结构==

- 索引存储一个或一组特定字段的值，按字段的值排序
- 索引项的排序支持有效的等值匹配和基于范围的查询操作

基本上，Mongo的索引与其他关系型数据库的索引类似



## 默认id索引

创建集合期间，Mongo在`_id`字段上创建唯一索引，该索引可以防止客户端插入两条具有相同值的文档

注意，在分片集群中，如果不使用`_id`字段作为分片键，那么应用程序必须确保`_id`的值的唯一性。这一特性通常是通过使用标准的自动生成的ObjectId来完成的



## 索引类型

单字段索引

复合索引：多字段上定义

- 复合索引中列出的字段顺序具有重要意义

文本索引

- 支持搜索集合中的字符串内容

多键索引

- 使用多键索引来索引存储在数组中的内容
- 对集合中的数组字段建立索引，会为数组中的每一项建立一个单独的索引

地理空间索引

- 返回结果时使用平面几何的2d索引
- 使用球面几何返回的2d sphere索引



索引子文档字段

> 对子文档建立索引，建立后，可以使用子文档的字段来检索数据



## 覆盖索引查询

- 所有的查询字段是索引的一部分
- 所有的查询，返回字段在同一个索引中

和MySQL的覆盖索引是类似的



不会使用覆盖索引的情况

- 索引字段是一个数组
- 索引字段是一个子文档



## 索引失效

- 正则表达式、一些非操作符（$nin、$not等）
- 算术运算符
- $where子句



# MongoDB查询分析

使用的函数是：explain()、hint()。和mysql使用explain类似





# MongoDB Map Reduce

Map-Reduce是一种计算模型，简单说就是将大批量的工作（数据）分解（Map)执行，然后将结果合并成最终结果（Reduce)

需要实现2个函数

- Map函数：emit(key,value)

  - 映射函数，作为Reduce函数的参数

- Reduce函数

  - 统计函数

  

​	

# MongoDB全文检索

对每一个词建立一个索引，指明该词在文中中出现的次数和位置，用户查询时，检索程序就会根据事先建立的索引进行查找，并将查找结果反馈给用户的检索方式

类似于：我们查询字典的过程





# MongoDB GridFS

用于存储和恢复那些超过16M的文件

GridFS也是一种文件存储的方式，但是它是存储在MongoDB的集合中

GridFS会将大文件对象分割成多个小的chunk，一般一个为256k,每个chunk将作为MongoDB的一个文档被存储在chunks集合中

GridFS用2个集合来存储一个文件：fs.files、fs.chunks

- fs.files：存储和文件有关meta数据
- fs.chunks:存储实际的文件



# MongoDB固定集合

Capped Collections,是性能出色且有着固定大小的集合，对于大小固定，当集合空间用完后，再插入元素，会覆盖最初始的头部的元素



​																																																																																										

# Change Streams

> 变更流，允许应用程序访问实时数据更改，而不会带来复杂性和延迟oplog的风险

应用程序使用变更流来订阅单个集合，数据库或整个部署中的所有数据变更，并立即对其做出反应

变更流可用于副本集和分片集







# MongoDB复制（副本集）

MongoDB的复制工具称为副本集 Replica set，是生产部署的基础，提供了冗余性和可靠性

==类似于：Mysql的主从复制架构==

- 确保通过在不同的机器上保存副本，来保证数据不会因为单点故障而丢失
- 一组复制集，就是一组MongeDB实例掌管同一个数据集，实例可以在不同的机器上





副本集特征

- N个节点的集群
- 任何节点可能作为主节点
- 写操作都在主节点
- 自动故障转移、自动恢复



复制集模式启动后，会在多个节点中选择一个Primary主节点

## 复制集有哪些成员

- 主节点:primary
  - 主节点接收所有的写操作
  - 副本服务器集群（从节点）包含所有的主服务器数据，当primary故障后，会在从节点集群中选举一个成为主服务器
  - priority0：节点选举优先级，为0代表不能被选为primary
- 从节点:Seconary
  - 从节点提供读取服务，增加Seconary节点可以提供复制集的读取能力，提供可用性
  - 复制主节点的oplog日志,并将这些操作应用于它们自己的数据集
- 仲裁节点 Arbiter
  - MongoDB中的仲裁节点，只参与投票，不会被选举为Primary，并且不会从Primary同步数据
  - Arbiter本身不存储数据，是非常轻量级的服务
  - Arbiter节点需要独立部署,不能部署在数据集节点中
  - 添加仲裁节点的原因：==为了确保复制集中，有奇数个投票成员==，否则primary宕机后，不能自动选举出新的primary提供服务



隐藏节点

- 节点设置为隐藏，客户端不会将读请求发送到该节点，即使设置了复制集读功能选项
- 可以将隐藏节点专用于报表节点或是备份节点
- 延时节点也应该是一个隐藏节点



延时节点

- 延迟节点的数据集是延时的，因此可以通过它帮助我们在人为误操作或其他意外情况下恢复数据
- 延时节点必须是隐藏节点，并且其数据与Primary落后一段时间（可配置时间）
- 



## 复制集常见部署架构

### 基础3节点

- 1主2从
  - 2个从节点选举primary时，可以不用借助仲裁节点完成自动选举切换
- 1主1从1仲裁



### 跨数据中心

单个数据中心的复制，容易受到数据中心估值的影响。例如：断电、断网、洪水等等。所有引入多个数据中心

**如果有可能，请至少在3个数据中心分配节点成员**



mongoDb primary节点选举机制

- 需要得到大多数的节点选举投票：N/2+1
- 如果整个复制集不能选举出Primary，则复制集无法提供写服务，处于只读状态
- 一个复制集最多50个节点，但是最多只有7个投票节点，一个非投票节点的属性votes=0，priority=0



## 复制集中的OptLog

oplog，操作日志，是一个特殊的有上限的集合（老的会被覆盖），它保存着所有修改数据库中存储的数据的操作的滚动记录

MonggoDB在主节点上应用数据库操作，将这些操作都记录到oplog中



## 异步复制

从节点复制主节点的oplog，是异步操作的，在local.oplogs.rs集合中，所有复制集成员都包含oplog的一个副本，来维护数据库的当前状态





# MongoDB分片

mongo中数据量很大时，应用对单机的性能造成较大压力，会影响查询效率

mongo提出了分片的概念，将数据集拆分到多个MongoDB实例中



类似于：Mysql的分库分表



MongoDB的核心功能之一，是提供横向可扩展性

- 分片会将数据分布在机器集群上



分片主要组件

- Shard
  - 存储实际的数据块，生产环境中一个Shard Server角色可由几台机器做成一个replica set承担，防止主机单点故障。即将：一个主从架构构成一个Shard
- Config Server
  - mongo实例，存储了整个cluster metadata,其中包括chunk信息
- Query Routers
  - 前端路由，客户端由此接入，且让整个集群看上去像单个数据库，前端应用透明使用



## 分片数据如何存储：Chunk

在一个Shard server内部，MongoDB会将数据分为chunks，每个chunk代表一部分数据



分片集群的数据分片（shard节点）

- 使用chunk存储数据
- 集群搭建完成后，默认开启一个chunk，默认大小64M
- 存储需求超过64M，chunk会进行分裂，若存储需求大，可设置更大的chunk容量
- chunk会被自动均衡迁移





chunk大小的选择

- 适合自己公司业务即可
- chunk的分裂和迁移都非常消耗IO资源
  - 小的chunksize：迁移速度快、数据分布更均匀，数据分裂频繁，路由节点消耗更多资源
  - 大的chunksize：数据分裂少，数据块移动集中消耗IO资源
- chunk分裂的时机
  - 插入、更新
  - 查询读取数据不会分裂



chunk分裂及迁移

- 当一个chunk数据大小超过默认配置64M，会分裂为2个chunk，一个32M
- 这时，各个shard上的chunk数量就会不平衡
  - 此时，mongodb中有一个balancer组件，会执行自动平衡
  - 把chunk从数量多的shard节点移动到数量少的节点





## 如何分片

分片依据和分片算法

分片依据：分片键值

分片算法：范围分片、哈希分片



分片键

> 在collection中选择一个或多个字段，用该键的值，作为数据拆分的依据

- 分片键必须有一个索引
- 分片键用于路由查询
- 大小限制在512B
- mongo不接受已进行collection级分片的collection上插入无分片



哈希分片

> 分片过程中，利用哈希索引作为分片，最大的好处是：保证数据在各个节点分布基本均匀



范围分片

> 将单个collection的数据分散在多个shard上，用户可以根据指的collection内文档的某个字段，即shard key(分片键)来进行范围分片



哈希+范围分片结合







# 正则表达式

基本上用于文档中发现字符串







# 系统设计-模式构建

使用mongodb时，经常被问到的问题是：我如何在mogoDB中，为我的应用程序构造模式(Scheme)？

- 你的程序读操作比写操作多吗？
- 从数据库中读取时，需要将那些数据放在一起
- 有哪些性能因素考虑
- 文档有多大，后续会变大吗？
- 预计数据会如何增值？如何扩展？

这些问题都涉及到如何在MongoDB中设计数据库模式



## 多态模式

> 当==集合中的所有文档都具有相似但不相同的结构==时，我们将其称为多态模式

例如：不同类型的职业运动员信息

- 这些记录文档既有相似之处，也有不同之处
- 如果不这样做：网球、篮球。。不同的运动员则需要单独存储为不同的集合
- 当要查询所有运动员时，需要进行耗时且复杂的连接操作



特点：允许在单个集合中进行所有信息的查询

应用场景

- 单一试图应用程序（所有的操作和展示都在一个单一的试图中进行）
- 内容管理
- 产品目录

多态模式是许多设计模式的起点



## 属性模式

> 处于性能考虑，为了优化搜索，我们可能会需要很多索引以照顾到所有子集
>
> 创建很多索引可能会降低性能。属性模式就是为这种情况提供了一个很好的解决方案



结论

- 属性模式针对每个文档中许多类似字段提供了更简单的文档索引
- 通过将这个数据子集移动到一个键值子文档中，统一处理



使用场景

- 有一些大文档，它们有很多相似的字段，而这些字段的一个子集具有共同的特征，我们希望对该子集字段进行查询或排序
- 我们需要排序或查询的字段只能在一小部分文档中找到



## 桶模式

> 这种模式在处理物联网（IoT)、实时分析、通用时间序列数据时提别有效
>
> 通过将数据放在一起，可以更容易的将数据组织成特定的组，提高发现历史趋势或提供未来预测的能力，同时还对存储进行优化



桶模式在许多情况下都非常有效



应用场景

- 时间序列增长的场景



## 异常值模式

> 文档中有异常值怎么办？
>
> 使用异常模式就是在防止一些少数的查询或文档将我们推向对大多数用例来说都不佳的解决方案

在文档中添加一个异常标记，程序处理时对该标记进行额外的处理





## 计算模式

> 它可以用于对集合中的数据进行计算或操作，并将结果存储在文档中，以避免重复进行相同的计算。
>
> 当你的系统在重复执行相同的计算，并且具有较高的读写比时，请考虑使用计算模式









## 子集模式



## 扩展引用模式



## 近似值模式



## 树形模式



## 预分配模式



## 文档版本控制模式



## 模式版本控制模式



## 结论

MongoDB文档模型，在如何建模数据方面提供了很大的灵活性

- 这种灵活性是非常强大的，==但是，这种能力需要根据应用的数据访问模式去驾驭利用==
- ==MongoDB中模式设计对应用程序的性能有着巨大的影响==
- 这些设计模式是可以在合理的情况下混合使用的









