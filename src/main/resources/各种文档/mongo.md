# Mongo

MongoDB是==面向文档==的NoSQL数据库，用于大量数据存储

## 主要功能

1. 每个数据库都包含集合，集合有包含文档
   - 每个文档可以具有不同数量的字段
   - 每个文档的大小和内容可以互不相同
2. MongoDB的行不需要预先定义结构，相反，可以动态创建字段



## MongoDB架构的关键组件

1. _id：这是每个mongoDB文档的必填字段，表示mongoDB文档中的唯一值
   - 文档必须包含一个`_id`字段，可以是任意类型的，默认是ObjectId对象
   - 类似于主键，创建新文档时，如果没有_id字段，会自动创建该字段
   - ObjectId是一个12字节Bson类型数据
     - 前4个字节：表示时间戳
     - 紧接着的3字节：机器标识码
     - 剩下3字节：随机数
2. 集合：这是mongoDB中，文档的分组
   - 等效于：关系型数据库中的表
   - 集合存在于单个数据库中
3. 游标：指向查询结果集的指针
4. 数据库：集合的容器，类似于关系型数据库的某个库
5. 文档：mongoDB集合中的记录，称为文档
   - 类似于关系型数据库的某条记录
   - 文档包含字段名和值
6. 字段：文档中的key/value对，一个文档可以具有0个或多个字段
7. Json：可读性高，用于表示结构化数据的纯文本格式





## 为什么需要MongoDB

1. 面向文档的，将数据存储在文档中，使得mongoDB非常灵活，可以适应实际的业务环境和需求
2. 临时查询
   - MongoDB支持按照字段、范围、正则表达式搜索，可以查询返回文档中的特定字段
3. 索引
   - 可以创建索引，以提高mongoDB的搜索性能
   - 文档中的任何字段都可以建立索引
4. 复制：提供了副本集的高可用
5. 负载均衡
   - 使用分片的功能，实现水平扩展





## mongoDB的数据建模

mongo的数据具有灵活的架构，不会强制执行文档结构，使得mongo具有很强的灵活性

在mongo中，对数据建模时，应注意以下几点

1. 应用程序的需求是什么
   - 基于需求确定文档的结构
2. 数据检索模式
   - 例如：使用大量的查询操作，那么考虑在数据模型中使用索引来提高查询效率
3. 数据库是否频繁发生crud操作
   - 如果数据建模设计需要重新考虑使用索引或合并分片，以提高整体mongo环境的效率



## mongoDB创建数据库和集合

- 使用“use”命令创建数据库
- 使用insert()创建集合
- 使用insert()添加文档
- find()查询文档
- sort、limit、orders字句类似sql语句的作用
- 学习的时，看api就可以了



## mongoDB安全、监控、备份

安全

1. 启用访问控制
2. 配置基于角色的访问控制
3. 尝试将mongoDB配置为某种加密协议
4. 配置审计
5. 使用单独的用户ID运行mongoDB服务器实例



mongoDB备份程序：mongodump

1. 通过复制底层数据文件进行备份
2. 使用mongodump备份数据库
3. mongoDB cloud manager备份





## 数据库和集合

一个MongoDB实例，可以创建多个数据库，一个库可以创建多个集合，一个集合由多个文档组成

MongoDB内建的库

- admin库：主要存放有数据库账户相关信息
- config库：用于分片集群环境，存放分片相关的元数据信息
- local库：该库永远不会被复制到从节点，可以用来存放限于本地单台服务器的任意集合副本集的配置信息、oplog就存储再local库





### Collection

> MongoDB将Bson文档(即数据记录)，存储在集合Collection中，集合相当于关系型表
>
> 集合不存在时，在第一次存储数据到该集合时，Mongo会自动创建该集合



#### 文档

- 文档验证
  - 默认情况下，集合不要求其文档具有相同的模式，也就是说，单个集合的文档，不需要具有相同的字段集，且字段的数据类型在集合的不同文档之间可以不
  - 但是，从Mongo3.2开始，可以在更新和插入操作期间，对集合强制执行`文档验证规则`
- 修改文档结构
  - 可以动态更改集合中文档的结构。例如：添加新的字段、删除现有字段

#### 唯一标识符

> 集合被分配一个不变的UUID,且副本集的所有成员和分片集群中的分片的集合UUID均相同



#### 视图

> mongo3.4开始，可以基于已存在的集合或者视图传教只读的视图View
>
> 类似于Mysql的视图

- 视图是只读的，通过视图进行写操作会出现错误
- 视图使用其上游集合的索引
  - 索引是基于集合的，所以==不能基于视图==创建索引、删除、重建索引，也不能获取视图的索引列表
  - 也不能指定$natural排序
- 不能重命名视图
- 如果视图依赖的集合是分片的，那么视图也视为分片的
  - 因此，不能指定分片视图中的$lookup的from字段与$graphLookup操作
- 删除视图、修改视图



## 文档

> 文档是MongoDB的基本存储单元，它以一种BSON的文档的结构表示
>
> MongoDB将数据记录存储为BSON结构的文档，BSON,Binary JSON，Json文档的二进制表示形式



文档大小限制：Bson文档的最大大小为16MB

- 防止单个文档过大或在传输过程中占用过多的带宽
- 要存储大于最大大小的文档，Mongo提供了GridFS





## CRUD

### 文本索引

Mongo支持对字符串内容的文本搜索查询，要执行文本搜索查询，必须在集合上有一个文本索引

- 一个集合只能有一个文本索引，但是该索引可以覆盖多个字段





# MongoDB关系

MongoDB的关系表示：多个文档之间在逻辑上的相互联系

文档之间可以通过：嵌入和引用来建立联系

- 嵌入式：把文档嵌入到其中
- 引用式：通过引用文档的`_id`字段来建立关系
  - 引用哪个数据库、哪个集合、哪个文档



Mongo中文档的关系可以是

- 1：1、1：N、N:1、N:N





# MongoDB数据库文件

> MongoDB的数据库文件和其存储引擎有直接的关系

MongoDB提供了3种存储引擎

1. MMAPV1
   - V3.2版本之前采用
   - V4.2中移除了MMAPV1
2. ==WiredTiger==
   - V3.2开始使用
3. In Memory



WiredTiger引擎下的数据库文件

- collection-*.wt文件：存储collection的数据
- index-*.wt：存储索引的数据
- WiredTiger:存储基本配置信息
- WiredTiger.wt：存储所有其他collection的元数据信息
- WiredTiger.lock：存储进程ID,用于防止多个进程连接同一个Wiredtiger数据库
- WiredTiger.turtle：存储WiredTiger.wt的元数据信息
- journal：存储Write ahead log



WiredTiger

> 一个优秀的单机数据库存储引擎

存储引擎要做的事情：无非就是把磁盘上的数据读取到内存返回给应用，或者将应用修改的数据由内存写入到磁盘上去

如何设计一种高效的数据结构和算法是所有存储引擎要考虑的根本问题

目前大多数流行的存储引擎都是**基于**B-Tree、LSM Tree这两种数据结构来设计的

- B-Tree
  - 像Oracle、MySQL(InnoDB)、PostgreSQL、DB2等这些传统的关系型数据库的底层存储引擎都依赖于B-Tree开发的
- LSM(Log Structured Merge)Tree
  - 像ElasticSearch(Lucene)、Google Big Table、Apache HBase、Cassandra等这些当前流行的NoSQL数据库存储引擎是基于LSM Tree开发的
- 插件式：兼容以上2种



MongoDB采用何种方式

> MongoDB也采用了插件式存储引擎架构，底层的WiredTiger存储引擎还支持B-Tree和LSM两种结构组织数据
>
> 但是，MongoDB再使用WiredTiger作为存储引擎时，==目前默认配置是B-Tree结构==

B-Tree：是为磁盘或其他辅助存储设备而设计的一种数据结构，目的是为了在查找数据的过程中，减少磁盘I/O的次数，因为节点就存储了数据







# Mongo事务

Mongo从4.0版本开始，才支持事务，2024-12-29已经是8.x版本了



Mongo中，对单个文档的操作是原子的

对于需要对多个文档（单个或多个集合中）进行原子性读写的场景，Mongo支持多文档事务。使用分布式事务，事务可以跨多个集合、数据库、文档和分片使用



多文档事务（分布式事务）

- 指的是分片集群和副本集群上的多文档事务



# Mongo索引

如果没有索引，mongo必须执行集合扫描，相当于Mysql的全表扫描

MongoDB索引是存储在内存中的

一个查询如果存在适当的索引，那么Mongo可以使用该索引来限制它必须检查的文档数量

Mongo的索引也是一种特殊的==数据结构==

- 索引存储一个或一组特定字段的值，按字段的值排序
- 索引项的排序支持有效的等值匹配和基于范围的查询操作

基本上，Mongo的索引与其他关系型数据库的索引类似



## 默认id索引

创建集合期间，Mongo在`_id`字段上创建唯一索引，该索引可以防止客户端插入两条具有相同值的文档

注意，在分片集群中，如果不使用`_id`字段作为分片键，那么应用程序必须确保`_id`的值的唯一性。这一特性通常是通过使用标准的自动生成的ObjectId来完成的



## 索引类型

单字段索引

复合索引：多字段上定义

- 复合索引中列出的字段顺序具有重要意义

文本索引

- 支持搜索集合中的字符串内容

多键索引

- 使用多键索引来索引存储在数组中的内容
- 对集合中的数组字段建立索引，会为数组中的每一项建立一个单独的索引

地理空间索引

- 返回结果时使用平面几何的2d索引
- 使用球面几何返回的2d sphere索引



索引子文档字段

> 对子文档建立索引，建立后，可以使用子文档的字段来检索数据



## 覆盖索引查询

- 所有的查询字段是索引的一部分
- 所有的查询，返回字段在同一个索引中

和MySQL的覆盖索引是类似的



不会使用覆盖索引的情况

- 索引字段是一个数组
- 索引字段是一个子文档



## 索引失效

- 正则表达式、一些非操作符（$nin、$not等）
- 算术运算符
- $where子句



# MongoDB查询分析

使用的函数是：explain()、hint()。和mysql使用explain类似





# MongoDB Map Reduce

Map-Reduce是一种计算模型，简单说就是将大批量的工作（数据）分解（Map)执行，然后将结果合并成最终结果（Reduce)

需要实现2个函数

- Map函数：emit(key,value)

  - 映射函数，作为Reduce函数的参数

- Reduce函数

  - 统计函数

  

​	

# MongoDB全文检索

对每一个词建立一个索引，指明该词在文中中出现的次数和位置，用户查询时，检索程序就会根据事先建立的索引进行查找，并将查找结果反馈给用户的检索方式

类似于：我们查询字典的过程





# MongoDB GridFS

用于存储和恢复那些超过16M的文件

GridFS也是一种文件存储的方式，但是它是存储在MongoDB的集合中

GridFS会将大文件对象分割成多个小的chunk，一般一个为256k,每个chunk将作为MongoDB的一个文档被存储在chunks集合中

GridFS用2个集合来存储一个文件：fs.files、fs.chunks

- fs.files：存储和文件有关meta数据
- fs.chunks:存储实际的文件



# MongoDB固定集合

Capped Collections,是性能出色且有着固定大小的集合，对于大小固定，当集合空间用完后，再插入元素，会覆盖最初始的头部的元素



​																																																																																										

# Change Streams

> 变更流，允许应用程序访问实时数据更改，而不会带来复杂性和延迟oplog的风险

应用程序使用变更流来订阅单个集合，数据库或整个部署中的所有数据变更，并立即对其做出反应

变更流可用于副本集和分片集







# MongoDB复制（副本集）

MongoDB的复制工具称为副本集 Replica set，是生产部署的基础，提供了冗余性和可靠性

==类似于：Mysql的主从复制架构==

- 确保通过在不同的机器上保存副本，来保证数据不会因为单点故障而丢失
- 一组复制集，就是一组MongeDB实例掌管同一个数据集，实例可以在不同的机器上





副本集特征

- N个节点的集群
- 任何节点可能作为主节点
- 写操作都在主节点
- 自动故障转移、自动恢复



复制集模式启动后，会在多个节点中选择一个Primary主节点

## 复制集有哪些成员

- 主节点:primary
  - 主节点接收所有的写操作
  - 副本服务器集群（从节点）包含所有的主服务器数据，当primary故障后，会在从节点集群中选举一个成为主服务器
- 从节点:Seconary
  - 从节点提供读取服务，增加Seconary节点可以提供复制集的读取能力，提供可用性
  - 复制主节点的oplog日志,并将这些操作应用于它们自己的数据集
- 仲裁节点 Arbiter
  - MongoDB中的仲裁节点，只参与投票，不会被选举为Primary，并且不会从Primary同步数据
  - Arbiter本身不存储数据，是非常轻量级的服务
  - Arbiter节点需要独立部署,不能部署在数据集节点中
  - 添加仲裁节点的原因：==为了确保复制集中，有奇数个投票成员==，否则primary宕机后，不能自动选举出新的primary提供服务



隐藏节点

- 节点设置为隐藏，客户端不会将读请求发送到该节点，即使设置了复制集读功能选项
- 可以将隐藏节点专用于报表节点或是备份节点
- 延时节点也应该是一个隐藏节点



延时节点

- 延迟节点的数据集是延时的，因此可以通过它帮助我们在人为误操作或其他意外情况下恢复数据
- 延时节点必须是隐藏节点，并且其数据与Primary落后一段时间（可配置时间）
- 



## 异步复制

从节点复制主节点的oplog，是异步操作的





# MongoDB分片

mongo中数据量很大时，会影响查询效率

mongo提出了分片的概念，将数据集拆分到多个MongoDB实例中



类似于：Mysql的分库分表



MongoDB的核心功能之一，是提供横向可扩展性

- 分片会将数据分布在机器集群上



分片主要组件

- Shard
  - 存储实际的数据块，生产环境中一个Shard Server角色可由几台机器做成一个replica set承担，防止主机单点故障。即将：一个主从架构构成一个Shard
- Config Server
  - mongo实例，存储了整个cluster metadata,其中包括chunk信息
- Query Routers
  - 前端路由，客户端由此接入，且让整个集群看上去像单个数据库，前端应用透明使用



# 正则表达式

基本上用于文档中发现字符串















