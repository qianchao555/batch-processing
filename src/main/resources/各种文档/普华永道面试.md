### 一面







### MySQL

1. 生产环境给一条慢sql，如何优化 

如何回答：

1. 慢查询原因：主要有3种情况
   - 加载了不需要的数据列
   - 没有命中索引
   - 数据量太大
2. 优化方案
   - 针对第一种情况：去掉多余的，没有用处的字段查询
   - explain分析执行计划
   - 若无法优化了已经，那么需要考虑是否数据表的量太大了导致的慢查询，如果是的化，则需要考虑横向或纵向分表
3. 



### 多线程

1. 项目中怎么用的
   - list分片，如何创建线程池大小的
   - list根据传入的每组大小，创建出分片数量，循环分片数量
   - 除开最后一个分片外，每个list都是一样的，根据此list的大小创建线程池
   - 这里是每次都创建一个线程池，应该可以优化这里。！！！
   
   
   
2. 多线程处理hashmap会出现什么问题，生产环境下不能多线程使用hashMap
   - 有什么解决方案：
     - 锁？
     - HashTable：synchronized方法
     - concurrentHashMap：段锁
     - Collections.synchronizedMap：封装一层synchronized 同步代码块 关键字
   - Java8中
     1. 有可能2个线程同时put，导致第二个线程将第一个线程的put操作覆盖
        - 在两个线程put元素的时候，产生哈希碰撞，导致两个线程得到同一个hash桶，则会出现覆盖的情况
     2. 多线程下，hashmap的put操作可能出现死循环
        - hashmap有采用链表解决冲突的场景，所以，在循环的时候，有线程对这个HashMap进行get的时候，可能产生死循环
   
3. Java线程池有哪些，本质上是利用：ThreadPoolExecutor对象来创建

   - newCachedThreadPool：创建一个可缓存线程池
   - newFixedThreadPool：创建一个固定大小线程池
   - newScheduledThreadPool：创建一个周期性执行任务的线程池
   - newSingleThreadPool：创建一个单线程的线程池



### 锁

1. 锁有哪些方式实现
   - synchronized
   - Lock
2. Lock有哪些实现
   - ReentrantLock -->  AQS
3. 乐观锁、悲观锁怎么理解的      cas



#### redis

1. redis怎么存储用户信息，应该用什么数据结构
1. 有哪些数据类型、平时用到了哪些
2. 内存淘汰机制有哪些



### 分布式锁

1. 项目中怎么用的
2. redisson如何实现锁资源的
   - lua



### Seata

1. seata事务是怎么实现的

2. 如何实现回滚的

3. A ->B ->C
   - 请求1：操作B服务中，id=2的记录，后调用C
   - 请求2：操作B服务中，id=2的记录，后调用C
   - 此时：请求1调用C发生了错误，发生回滚，seata是怎么解决的
   
4. 第三问的问题转化：Seata AT模式，二阶段回滚时，待回滚数据被别的事务修改，回滚失败。

   - 本质原因：Seata AT模式，整个事务过程中，没有一直锁定数据

   1. 二阶段回滚时：seata会做数据校验，拿着undo_log里面的数据和当前数据比较，如果有不同，说明数据被当前全局事务之外的动作做了修改。这种情况，需要根据配置策略来做处理
   2. 不过官网给的建议是：关掉二阶段undo_log镜像校验，防止报错，不过这是不可取的
   3. 所以通常情况下如果发生了这种情况，需要额外处理或人工处理
   4. 不过可以采用TCC模式，这样会一直锁定资源，问题就是需要注意TCC的缺点





### 幂等性

> 如何保证幂等性：推荐使用分布式锁方式

1. 项目中怎么做的：aop切面

2. 其他有什么方式
   - 数据库：大致3种解决方案
   
     - 唯一索引实现：唯一索引的字段就是业务id，插入失败证明是冲入插入的
   
     - 悲观锁：结合事务使用，mysql中，注意id要是主键或唯一索引否则肯能造成表锁
   
     - ~~~mysql
       begin;  # 1.开始事务
       select * from table_name where id='xxx' for update; # 2.查询状态
       insert into table_name (id) values ('xxx'); # 3.添加操作
       update table_name set status='xxx'; # 4.更改操作
       commit; # 5.提交事务
       ~~~
   
     - 乐观锁：通过版本号来实现
   
     
   
   - Lock接口锁：分布式环境下有问题
   
     - 不过只有在一个JVM中才生效
   
     - 当系统采用集群方式部署时，这个锁就不生效了，需要用到下面的分布式锁
   
       
   
   - 分布式锁
   
     - zk
     - redis
       - 主要是利用：
       - setNx：向redis中存k-v，当key不存在时才会设置成功，否则返回0。用于体现互斥性
       - expire：设置key的过期时间，避免死锁出现
       - delete：删除key，用于释放锁
     - redisson分布式锁



大环境都找不到工作，你有什么优势



### 红黑树

> 是一种特殊的平衡二叉查找树，每个节点上都增加了一个存储位，用于表示节点的颜色，可以是red或black
>
> 通过对任何一条从根节点到叶子节点的路径上各个节点着色方式的限制，红黑树确保没有一条路径会比其他路径长出两倍，因而是接近平衡的



#### 二叉查找树

> 也叫有序二叉树、排序二叉树，是指一颗空树或具有以下性质的二叉树

1. 若任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值
2. 若任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值
3. 任意节点的左、右子树也分别为二叉查找树
4. 没有键值相等的节点



红黑树在二叉查找树的基础上添加了：节点着色和相关的性质，使得红黑树相对平衡，从而保证了红黑树的查找、插入、删除的时间复杂度最坏为O(logn)



红黑树的5个性质，保证了n个节点的红黑树的高度始终保持在logn

1. 每个节点要么是黑，要么是红
2. 根节点是黑的
3. 每个叶节点是黑色的（红黑树的叶节点都是null的）
4. 如果一个节点是红色的，那么它的两个儿子都是黑色的
5. 对于任意节点，其到叶节点尾端null指针的每条路径都包含相同数目的黑色节点



#### 红黑树的旋转

> 当对红黑树进行插入、删除节点时，可能会破环红黑树的性质，未来保持红黑树的性质，可以通过对节点重写着色、旋转等操作来维持红黑树特性
>
> 即：通过修改树的某些节点颜色以及指针结构，使红黑树实质保持其特性

##### 左旋

##### 右旋

红黑树的旋转使得该树保持为原来的搜索性质，即查找性质，但是不能保证红黑节点着色不能保证，所以需要在红黑树插入、删除的时候利用旋转和重写着色一起来保证红黑树性质



红黑树插入操作

1. 将红黑树当作一颗二叉查找树，将节点插入
2. 将插入的节点着色为"红色"
3. 通过一些列旋转或重新着色，使树成为红黑树



### Java中的红黑树

TreeMap、TreeSet采用了红黑树实现

HashMap满足一定情况下也会改为红黑树





### 一面中没有回答好的地方

1. 多线程处理hashmap可能出现什么情况
2. hashmap的put操作、转红黑树过程
3. list分片，为什么要每次都去创建线程池？这里是需要优化成只创建一次线程池的
4. Seata AT模式，二阶段回滚时，待回滚数据被别的事务修改，回滚失败。Seata AT模式，没有一直锁定数据。
   - seata是如何处理的



### 二面

1. 为什么离职

2. 现在多少、期望多少

3. mysql

   - （a,b)+delete标识，现在要如何保证唯一性，从代码层面如何保证
   - on后面追加过滤条件，和使用where区别

4. @Transactional

   - 事务的使用情况
   - 传播机制

5. 让你设计一个sso怎么搞

6. 如何设计一个第三方接口

   - token鉴权
     - 借鉴腾讯云
     - 给用户一个类似于token的key，以及一个密钥
     - 通过传入这两个标识来标识自己有权限访问某一个接口
   - 接口加密、加密算法
     - 利用htts防止接口数据明文传输
     - 接口签名(加密)，目的是防止参数被篡改
     - 

7. Kafka如何保证消息不丢失

8. Eureka、Nacos、Zk的区别

9. Jenkins+openshift的优势

   