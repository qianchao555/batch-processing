## Java虚拟机

```
- 程序执行之前，把Java代码编译为字节码文件（class文件），JVM首先需要把字节码 通过类加载器，把文件加载到运行时数据区。
- 而字节码文件是Jvm的一套指令集规范，不能直接交给底层操作系统去执行，因此需要特定的命令解析器（执行引擎）将字节码翻译成底层系统指令，再交给CPU去执行，执行过程中，需要调用其他语言的接口（本地库接口）来实现整个程序的功能

1. 类加载器
2. 运行时数据区
3. 执行引擎
4. 本地库接口
```

1. Sun Classic/Exact VM

2. **HotSpot VM**

   - 武林盟主

   - oracleJdk、openJdk中默认使用的虚拟机

3. Mobile/Embedded VM

4. BEA JRockit/IBM J9 VM

   - 天下第二

5. 等等一系列VM

## 自动内存管理

### Java内存区域与内存溢出异常

#### 运行时数据区域

1. 程序计数器
   - 当前线程所执行到的字节码的行号指示器
   - 字节码解析器的工作是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、异常、线程恢复等基础功能都需要依赖这个计数器来完成
   - 线程私有的，每个线程都有独立的程序计数器
   - 异常规定：无，也是Jvm规范中没有规定OOM的区域 OutOfMemoryError
2. Java虚拟机栈
   - 描述的是Java方法执行的内存模型，每个方法在执行的同时都会创建一个"栈帧"，用于存储局部变量表、操作数栈、对象引用、动态链接、方法出口等信息，每个方法从调用直至执行完成的过程，都对应着一个栈帧在虚拟机栈中入栈到出栈的过程
   - 特性：线程私有，什么周期同线程相同
   - 异常规定
     - StackOverflowError：线程请求的栈深度大于虚拟机所允许的栈深度就会抛出该异常
     - OOM：扩展时，无法申请足够的内存就会抛出该异常
3. 本地方法栈
   - 与Java虚拟机栈作用一样，只不过服务于native方法
4. Java堆
   - Java虚拟机中内存最大的一块，所有线程共享，在虚拟机启动时创建，几乎所有的对象实例都在这里分配内存
   - 异常规定：OOM 堆中没有内存完成实例分配，并且堆不可以再扩展时
5. 方法区 / （HostSpot jdk8之前称为永久代 ，方法区的一种实现方式而已） （非堆）
   - 存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据
   - 运行时常量池：方法区的一部分，存放编译期生成的各种字面量和符号引用   ==》为其分配空间
     - 字面量：属于Java语言层面的概念
       -  字符串、生命为final的常量等等   例如：String str ="abc"   abc就是字面量
     - 符号引用：属于编译原理层面的概念，包括三种类型的常量
       - 类和接口的全限定名
       - 字段名称和描述符
       - 方法名称和描述符
   - 常量池：也叫静态常量池，在编译后的class文件，分为字面量和符号引用量，还没有加载到JVM中
   - 运行时常量池：JVM加载class文件，并为静态常量池分配内存空间，此时的常量池即为运行时常量池。除了编译后产生的常量，这个常量池在运行时，还会增加新的常量：String.intern()方法生成的新的字符串常量、由基本数据生成的包装类型
6. 直接内存：并不是运行时数据区的一部分，这部分内存被频繁使用可能导致OOM，JDK 1.4中新加入了NIO类，引入了一种基于Channel与缓冲区Buffer的IO方式，它通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用操作，它因此更高效，它避免了Java堆和Native堆来回交换数据的时间

- ![image-20211125140148249](C:/Users/2521573/AppData/Roaming/Typora/typora-user-images/image-20211125140148249.png)

#### HotSpot虚拟机对象探秘

1. 对象的创建
   - JVM遇到一条字节码new指令时，首先检查这个指令的参数是否能在常量池中定位到一个符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程
   - 类加载检查后，虚拟机为新生对象分配内存
   - 对象所需的内存大小在类加载完成后便可完全确定
   - 内存分配完成之后，JVM必须为分配到的内存空间都初始化为零值，这一步操作保证了对象的实例字段在Java代码中可以不赋初始值就可以直接使用，程序能访问到这些字段的数据类型所对应的零值
2. 对象的内存布局
   - HotSpot VM中，对象在堆内存中的存储布局分为三个部分
   - 对象头
     - 第一部分：存储对象自身的运行时数据，例如：哈希码、GC分代年龄、锁状态标识、线程持有锁等，这部分数据在32位和64位的虚拟机中分别为32bit和64bit，官方称为 Mark Word
     - 第二部分：类型指针，对象指向它的类型元数据的指针，JVM通过这个指针来确定该对象是哪个类的实例
     - 如果对象是一个Java数组，那么对象头中，还有一块记录数组长度的数据
   - 实例数据
     - 对象真正存储的有效信息
     - HotSpot VM 默认分配顺序：longs/doubles、ints、shorts/chars、bytes/booleans、oop(Ordinary Object Pointers)，相同宽度的字段总是分配到一起存放。在满足这个前提条件下，在分类中定义的变量会出现在子类之前。
   - 对齐填充
     - 不是必然存在的，也没有特别的含义，仅仅是占位符的作用
     - HotSpot VM的自动内存管理系统要求对象起始地址必须是8Byte的整数倍，也就是说任何对象的大小必须是8字节的整数倍，对象头已经精心设计为8字节的倍数了，因此，对象实例数据部分没有对齐的话，就需要通过对齐填充来补全
3. 对象的访问定位
   - Java程序通过栈上的引用数据来操作堆上的具体数据
   - 《Java虚拟机规范》中，引用类型只规定了它是一个指向对象的引用，并没有定义这个引用应该通过什么方式去定位、访问堆中对象的具体位置，所以，对象的访问方式也是根据虚拟机的实现而定的
   - 主流的访问方式
     - 句柄
       - 会从堆中划分一块内存作为句柄池，引用存放对象的句柄地址
       - 句柄中包含对象实例数据与类型数据各自的具体地址信息
     - 直接指针 
       -  HotSpot采用此种方式
       - 引用直接存放堆中对象的地址，且这个对象中存放着类型数据的地址指针

---

### 垃圾收集器与内存分配策略

#### 对象已死？

垃圾收集器在对堆进行回收前，第一件事情是确定这些对象是否还存活着

##### 引用计数法

1. 在对象中添加一个引用计数器，每当有地方引用它时，计数器就加一；当引用失效时，计数器减一；任何时刻计数器为零的对象就是不可能在被使用的
2. 主流的JVM都没有采用此算法来管理内存
3. 缺点：很难解决对象之间相互循环引用的问题

##### 可达性分析算法

1. 通过一系列称为 GC Roots 的根对象作为起始节点，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为"引用链"，如果某个对象到GC Roots没有任何引用链相连==》从GC Roots到这个对象不可达时，则证明此对象是不可能在被使用的
2. Java体系中，可固定作为GC Roots的对象包括
   - 虚拟机栈（栈帧中的本地变量表）中引用的对象 例如：各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等
   - 方法区中类静态属性引用的对象、常量引用的对象
   - 本地方法栈中引用的对象
   - Java虚拟机内部的引用，如：基本数据类型对应的Class对象，一些常驻的异常对象，系统类加载器等
   - 所有被同步锁持有的对象

##### 再谈引用

判断对象是否存活，都和引用离不开关系。因为引用指向着对象

1. 强引用
   - 程序中普遍存在的引用，类似：Object o=new Object()
   - 只要强引用关系还存在，那么GC就永远不会回收掉被引用的对象
2. 软引用
   - 描述一些还有用，但是非必须的对象
   - 只被软引用关联的对象，系统发送内存溢出前，会把这些对象列入回收范围之中进行第二次回收，如果这次回收还没有足够的内存，那么才会抛出内存溢出异常
3. 弱引用
   - 也是用来描述那些非必须对象，但是它的强度比软引用更弱一些
   - 被弱引用关联的对象只能生存到下一次垃圾收集发生为止。当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。
4. 虚引用
   - 一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例
   - 为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知

##### 生存还是死亡

1. 被判定为不可达对象，并非非死不可，要真正宣告一个对象死亡，至少要经过两次标记过程
   - 没有到达GC Roots的引用链，被第一次标记
   - 随后，进行一次筛选，看此对象是否有必要执行finalize()方法。如果对象没有覆盖此方法，或者此方法已经被虚拟机调用了，那么虚拟机视为不必要执行
   - 若为有必要执行finalize()方法。。。
   - finalize方法是对象逃脱死亡的最后一次机会，如果对象要在这finalize()方法中成功拯救自己--只要重新与引用链上的任意对象建立联系即可。如果对象不在这时候逃脱，那么基本上就是真的回收了

##### 回收方法区

方法区的垃圾收集主要两部分内容

1. 废弃的常量
2. 不再使用的类型

---



#### 垃圾收集算法

##### 引用计数式垃圾收集    也叫直接垃圾收集

1. 主流Java虚拟机中均未涉及

###### 追踪式垃圾收集           也叫间接垃圾收集



##### 分代收集理论

1. 弱分代假说
   - 大多数对象都是朝生夕灭的
2. 强分代假说
   - 熬过越多次垃圾收集过程的对象越消亡
3. 跨代引用假说
   - 跨代引用相对于同代引用来说仅占极少数

分代假说共同奠定了多款垃圾收集器的一致设计原则

1. 收集器将Java堆划分不同的区域
2. 将回收对象依据年龄分配到不同的区域中存储   年龄：对象熬过垃圾收集过程的次数

根据分代理论现代JVM一般至少将Java堆划分为

1. 新生代 Young Generation
   - 每次垃圾收集时都发现有大批对象死去，而每次回收后存活的少量对象，将会逐步晋升到老年代中存放
2. 老年代 Old Generation

GC分类

1. 部分收集Partial GC

   - 指目标不是完整收集整个Java堆的垃圾收集

   - 新生代收集Minor GC/Young GC：收集目标只是新生代的垃圾收集

   - 老年代收集Major GC/Old GC：指目标只是老年代的垃圾收集、目前只有CMS收集器会有单 

     独收集老年代的行为

   - 混合收集 Mixed GC：指目标是收集整个新生代以及部分老年代的垃圾收集。目前只有G1收 

     集器会有这种行为

2. 整堆收集 Full GC

   - 收集整个Java堆和方法区的垃圾收集

##### 标记-清除算法

1. 首先标记出所有需要回收的对象，标记完成后，统一回收掉所有被标记的对象
2. 标记过程就是对象是否属于垃圾的判定过程
3. 缺点
   - 执行效率不稳定，如果Java堆中有大量对象，而且大部分都是需要回收的，这时必须进行大量标记和清除动作，这个过程随着对象的增多效率降低
   - 内存空间碎片化问题，标记、清除会产生大量不连续的内存碎片，空间碎片太多，可能导致程序运行过程中需要分配较大对象时，无法找到足够连续的内存，而不得不提前触发一次垃圾收集动作
4. ![image-20211217141244716](C:/Users/2521573/AppData/Roaming/Typora/typora-user-images/image-20211217141244716.png)

##### 标记-复制算法 

1. 又称复制算法，为解决标记-清楚算法面对大量可回收对象时执行效率低的问题
2. 半区复制算法
3. 将可用内存按容量划分大小相等的两块，每次只使用其中的一块
4. 当一块内存用完了，就将还存活的对象复制到另一块上，然后把已经使用过的内存空间一次清理掉
5. 缺点
   - 可用内存缩小为原来的一般，空间浪费太多
6. 现代大多数JVM都采用此种收集算法**来回收新生代**
   - 新生代中的对象98%都熬不过第一轮回收，所以并不需要按照1：1的比例来划分新生代的内存空间
   - 针对这种对象的特点，提出了一种半区复制分代策略，称为"Appel式回收"，HotSpot VM 的Serial、ParNew等新生代收集器均使用此种策略来设计新生代的内存分布
   - 具体做法
     - 把新生代分为一块较大的Eden空间和两块较小的Survivor空间，每次分配内存只使用Eden和Survivor其中的一块，即：新生代空间==》Eden:Survivor:Survivor  8:1:1  
     - 当发生垃圾收集时，将Eden和Survivor中仍存活的对象一次性复制到另一块Survivor空间上，然后清理掉Eden和Survivor的空间
     - HotSpot VM 默认Eden和Survivor大小比例为8：1，即：每次新生代中**可用空间**为整个新生代容量的90%
     - 因为不能保证100%每次回收都只要不多于10%的对象存活，所以还得设计一个当Survivor空间不足以容纳一次Minor GC（针对新生代回收）之后存活的对象时，需要依赖其他内存区域（大多是老年代）进行分配担保
     - Survivor空间没有足够空间存放上一次新生代收集下来的存活对象，这些对象便将通过分配担保机制直接进入老年代
7. ![image-20211217142110952](C:/Users/2521573/AppData/Roaming/Typora/typora-user-images/image-20211217142110952.png)

##### 标记-整理算法

1. 针对老年代存亡特征而设计
2. 先标记需要回收的对象
3. 让所有存活的对象向内存空间一端移动，然后直接清理掉边界以外的内存
4. 与标记-清除算法区别
   - 清除算法是一种非移动式的回收算法
   - 整理是移动式的
5. ![image-20211217150553381](C:/Users/2521573/AppData/Roaming/Typora/typora-user-images/image-20211217150553381.png)

#### HotSpot的算法细节实现

---

#### 经典垃圾收集器

![image-20211217151616114](C:/Users/2521573/AppData/Roaming/Typora/typora-user-images/image-20211217151616114.png)

1. Serial收集器   采用标记-复制算法

   - 当它进行垃圾收集时，必须暂停其他所有工作线程，直到它收集结束
   - 当时这项工作是虚拟机后台自动发起和完成的
   - 迄今为止，它依然是HotSpot虚拟机运行在客户端模式下的默认新生代收集器

2. ParNew收集器   采用标记-复制算法

   - 实际是Serial收集器的多线程并行版本

3. Parallel Scavenge收集器   采用标记-复制算法

   - 关注点：达到一个可控制的吞吐量
   - 吞吐量：运行用户代码时间 / 运行用户代码时间+运行垃圾收集时间

4. Serial Old收集器   采用标记-整理算法

   - Serial的老年代版本
   - 主要意义：提供客户端模式下的HotSpot VM使用
   - 服务端模式意义
     - JDK5以及之前与Parallel Scavenge收集器搭配使用
     - 作为CMS收集器发生失败时的后备预案

5. Parallel Old收集器 采用标记-整理算法

6. CMS收集器  Concurrent Mark Sweep   基于标记-清除算法

   - 一种以获取最短回收停顿时间作为目标的收集器
   - 运作过程包含四步
   - 初始标记
     - 标记GC Roots能直接关联到的对象 
   - 并发标记
     - 从GC Roots的直接关联对象开始遍历整个对象图的过程
   - 重新标记
     - 修正并发标记期间，因用户程序继续运作儿导致标记产生变动的那一部分对象的标记记录
   - 并发清除
     - 清理删除掉标记阶段判断的已经死亡的对象，由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的

7. Garbage First收集器  G1

   - 主要面向服务端应用的垃圾收集器

   - 它面向堆内存任意部分来组成回收集进行回收，衡量标准不再是它属于哪个分代，而是哪块内存中存放的垃圾数量最多，回收利益最大，这就是G1收集器的Mixed GC模式

   - G1开创了基于Region的堆内存布局是实现这个目标的关键

   - 虽然G1也仍是遵循分代收集理论设计的，但其堆内存的布局与其他收集器有非常明显的差异

   - G1不再坚持固定大小以及固定数量的分代区域划分，而是把连续的Java堆划分为多个大小相等的独立区域（Region），每一个Region都可以根据需要，扮演新生代的Eden空间、Survivor空间，或者老年代空间

   - 收集器能够对扮演不同角色的Region采用不同的策略去处理，这样无论是新创建的对象还是已经存活了一段时间、熬过多次收集的旧对象都能获取很好的收集效果

   - Region中还有一类特殊的Humongous区域，专门用来存储大对象。G1认为只要大小超过了一个Region容量一半的对象即可判定为大对象。每个Region的大小可以通过参数-XX：G1HeapRegionSize设定，取值范围为1MB～32MB，且应为2的N次幂。而对于那些超过了整个Region容量的超级大对象，将会被存放在N个连续的Humongous Region之中，G1的大多数行为都把Humongous Region作为老年代的一部分来进行看待

   - G1收集器的运作过程

   - 初始标记

     - 标记GC Roots能直接关联到的对象，并且修改TAMS 指针的值，让下一阶段用户线程并发运行时，能正确地在可用的Region中分配新对象

   - 并发标记

     - 从GC Root开始对堆中对象进行可达性分析，递归扫描整个堆 

       里的对象图，找出要回收的对象

   - 最终标记

     - 对用户线程做另一个短暂的暂停，用于处理并发阶段结束后仍遗留 下来的最后那少量的SATB记录

   - 筛选回收

     - 负责更新Region的统计数据，对各个Region的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个Region构成回收集，然后把决定回收的那一部分Region的存活对象复制到空的Region中，再清理掉整个旧Region的全部空间。这里的操作涉及存活对象的移动，是必须暂停用户线程，由多条收集器线程并行 完成的



---

#### 低延迟垃圾收集器

1. Shenandoa
2. ZGC

---



#### 选择合适的垃圾收集器

#### 实战：内存分配与回收策略

---







### JVM性能监控、故障处理工具

---

### 调优案例分析与实战

---

## 虚拟机执行子系统

### 类文件结构

#### 无关性基石

1. 并非只有Java是运行在Java虚拟机上面的。例如：Kotlin、Groovy、JRuby、Scala等
2. 实现语言无关性的基础是**虚拟机和字节码存储格式**
3. Java虚拟机不与任何程序语言绑定，而只与"Class文件"这种特定的二进制文件格式关联
4. Class文件中包含了JVM指令集、符号表以及其他若干辅助信息
5. ![image-20211217173127295](C:/Users/2521573/AppData/Roaming/Typora/typora-user-images/image-20211217173127295.png)

#### Class类文件的结构

#### 字节码指令简介

#### 公有设计私有实现

#### Class文件结构的发展

---



### 虚拟机类加载机制

### 虚拟机字节码执行引擎

### 类加载及执行子系统的案例与实战















































## 面试题

### JVM的主要组成部分以及作用

- 程序执行之前，把Java代码编译为字节码文件（class文件），JVM首先需要把字节码 通过类加载器，把文件加载到运行时数据区。
- 而字节码文件是Jvm的一套指令集规范，不能直接交给底层操作系统去执行，因此需要特定的命令解析器（执行引擎）将字节码翻译成底层系统指令，再交给CPU去执行，执行过程中，需要调用其他语言的接口（本地库接口）来实现整个程序的功能

1. 类加载器
2. 运行时数据区
3. 执行引擎
4. 本地库接口

### 

---

### 堆栈区别

1. 堆和栈是完全不同的两块内存区域
2. 堆是线程共享的，堆中主要存放对象实例
3. 栈是线程私有的，栈主要存放各种基本类型数据、对象的引用

---



### Java中的参数传递时传值呢？还是传引⽤？

### **Java** 对象的⼤⼩是怎么计算的

### 对象的访问定位的两种⽅式

### 判断垃圾可以回收的⽅法有哪些

### 垃圾回收是从哪⾥开始的呢

### 被标记为垃圾的对象⼀定会被回收吗

### **谈谈对** **Java** 中引⽤的了解

### 谈谈对内存泄漏的理解

### 内存泄露的根本原因是什么

### 举⼏个可能发⽣内存泄漏的情况

**尽量避免内存泄漏的⽅法？**

常⽤的垃圾收集算法有哪些



什么是浮动垃圾？**

谈谈你对 **CMS** **垃圾收集器的理解

**G1** 收集器的理



如何利⽤监控⼯具调优





JVM的⼀些参数？**





谈谈你对类加载机制的了解



类加载各阶段的作⽤分别是什么



有哪些类加载器？分别有什么作⽤



类与类加载器的关系



**双亲委派模型的⼯作过程：**



**使⽤双亲委派模型的好处：**





怎么打破双亲委派模型



有哪些实际场景是需要打破双亲委派模型的



谈谈你对编译期优化和运⾏期优化的理解



**HotSpot** **虚拟机要使⽤解释器与编译器并存的架构？**



### Java**内存模型的理解

