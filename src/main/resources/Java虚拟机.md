## Java虚拟机

```
- 程序执行之前，把Java代码编译为字节码文件（class文件），JVM首先需要把字节码 通过类加载器，把文件加载到运行时数据区。
- 而字节码文件是Jvm的一套指令集规范，不能直接交给底层操作系统去执行，因此需要特定的命令解析器（执行引擎）将字节码翻译成底层系统指令，再交给CPU去执行，执行过程中，需要调用其他语言的接口（本地库接口）来实现整个程序的功能

1. 类加载器
2. 运行时数据区
3. 执行引擎
4. 本地库接口
```

1. Sun Classic/Exact VM

2. **HotSpot VM**
   - 武林盟主
   
   - oracleJdk、openJdk中默认使用的虚拟机
   
3. Mobile/Embedded VM

4. BEA JRockit/IBM J9 VM

   - 天下第二

5. 等等一系列VM

## 自动内存管理

### Java内存区域与内存溢出异常

#### 运行时数据区域

Java虚拟机在执行Java程序的过程中，会把它所管理的内存划分为若干个不同的数据区域，这些区域有各自的用途，以及创建和销毁的时间。根据《Java虚拟机规范》的规定，Java虚拟机所管理的内存将包括以下几个运行时数据区域：堆、虚拟机栈、本地方法栈、方法区、程序计数器

![image-20220316144451868](https://gitee.com/qianchao_repo/pic-typora/raw/master/img/image-20220316144451868.png)

1. 程序计数器
   - 当前线程所执行到的字节码的行号指示器
   - 字节码解析器的工作是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、异常、线程恢复等基础功能都需要依赖这个计数器来完成
   - 线程私有的，每个线程都有独立的程序计数器
   - 异常规定：无，也是Jvm规范中没有规定OOM的区域 OutOfMemoryError
   
2. Java虚拟机栈
   - 描述的是Java方法执行的内存模型，每个方法在执行的同时都会创建一个"栈帧"，用于存储局部变量表、操作数栈、对象引用、动态链接、方法出口等信息，每个方法从调用直至执行完成的过程，都对应着一个栈帧在虚拟机栈中入栈到出栈的过程
   - ![image-20220316164319035](https://gitee.com/qianchao_repo/pic-typora/raw/master/img/image-20220316164319035.png)
   
   - 特性：线程私有，生命周期同线程相同
   - 异常规定
     - StackOverflowError：线程请求的栈深度大于虚拟机所允许的栈深度就会抛出该异常
     - OOM：扩展时，无法申请足够的内存就会抛出该异常
   
3. 本地方法栈
   - 与Java虚拟机栈作用一样，只不过服务于native方法
   
4. Java堆
   - Java虚拟机中内存最大的一块，所有线程共享，在虚拟机启动时创建，几乎所有的对象实例都在这里分配内存，根据《Java虚拟机规范》规定，Java堆可用处于物理上不连续的内存空间中，但在逻辑上应该视为是连续的。但是对于大对象，多数虚拟机实现出于实现简单、存储高效的考虑，很可能要求连续的内存空间
   - 异常规定：OOM 堆中没有内存完成实例分配，并且堆不可以再扩展时
   
5. 方法区 / （HostSpot jdk8之前称为永久代 ，方法区的一种实现方式而已） （非堆）
   - 存储已被虚拟机加载的**类信息、常量、静态变量、即时编译后的代码等数据**
   
   - Java8 采用在本地内存中实现的**元空间**来实现方法区（类信息在本地内存保存）
   
   - ![image-20220316153439225](https://gitee.com/qianchao_repo/pic-typora/raw/master/img/image-20220316153439225.png)
   
   - 思考一下，为什么使用元空间替换永久代？
   
     表面上看是为了避免OOM异常。因为通常使用PermSize和MaxPermSize设置永久代的大小就决定了永久代的上限，但是不是总能知道应该设置为多大合适, 如果使用默认值很容易遇到OOM错误。
   
     当使用元空间时，可以加载多少类的元数据就不再由MaxPermSize控制, 而由系统的实际可用空间来控制。
   
     更深层的原因还是要合并HotSpot和JRockit的代码，JRockit从来没有所谓的永久代，也不需要开发运维人员设置永久代的大小，但是运行良好。同时也不用担心运行性能问题了,在覆盖到的测试中, 程序启动和运行速度降低不超过1%，但是这点性能损失换来了更大的安全保障
   
   - 运行时常量池：方法区的一部分，存放编译期生成的各种字面量和符号引用以及符合引用翻译出来的直接引用也存储在运行是常量池
     - 字面量：属于Java语言层面的概念
       -  字符串、生命为final的常量等等   例如：String str ="abc"   abc就是字面量
     - 符号引用：属于编译原理层面的概念，包括三种类型的常量
       - 类和接口的全限定名
       - 字段名称和描述符
       - 方法名称和描述符
     
   - 常量池：也叫静态常量池，在编译后的class文件，分为字面量和符号引用量，还没有加载到JVM中
   
   - 运行时常量池：JVM加载class文件，并为静态常量池分配内存空间，此时的常量池即为运行时常量池。除了编译后产生的常量，这个常量池在运行时，还会增加新的常量：String.intern()方法生成的新的字符串常量、由基本数据生成的包装类型
   
6. 直接内存：并不是运行时数据区的一部分，这部分内存被频繁使用可能导致OOM，JDK 1.4中新加入了NIO类，引入了一种基于Channel与缓冲区Buffer的IO方式，它通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用操作，它因此更高效，它避免了Java堆和Native堆来回交换数据的时间

- ![image-20211125140148249](https://gitee.com/qianchao_repo/pic-typora/raw/master/img/image-20211125140148249.png)

#### HotSpot虚拟机对象探秘

1. 对象的创建
   - JVM遇到一条字节码new指令时，首先检查这个指令的参数是否能在常量池中定位到一个符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程
   - 类加载检查后，虚拟机为新生对象分配内存
   - 对象所需的内存大小在类加载完成后便可完全确定
   - 内存分配完成之后，JVM必须为分配到的内存空间都初始化为零值，这一步操作保证了对象的实例字段在Java代码中可以不赋初始值就可以直接使用，程序能访问到这些字段的数据类型所对应的零值
2. 对象的内存布局
   - HotSpot VM中，对象在堆内存中的存储布局分为三个部分：对象头、实例数据、对象填充
   - ![image-20220316154721053](https://gitee.com/qianchao_repo/pic-typora/raw/master/img/image-20220316154721053.png)
   - 对象头
     - 第一部分：存储对象自身的运行时数据，例如：哈希码、GC分代年龄、锁状态标识、线程持有锁等，这部分数据在32位和64位的虚拟机中分别为32bit和64bit，官方称为 Mark Word
     - 第二部分：类型指针，对象指向它的类型元数据的指针，JVM通过这个指针来确定该对象是哪个类的实例
     - 如果对象是一个Java数组，那么对象头中，还有一块记录数组长度的数据
   - 实例数据
     - 对象真正存储的有效信息
     - HotSpot VM 默认分配顺序：longs/doubles、ints、shorts/chars、bytes/booleans、oop(Ordinary Object Pointers)，相同宽度的字段总是分配到一起存放。在满足这个前提条件下，在分类中定义的变量会出现在子类之前。
   - 对齐填充
     - 不是必然存在的，也没有特别的含义，仅仅是占位符的作用
     - HotSpot VM的自动内存管理系统要求对象起始地址必须是8Byte的整数倍，也就是说任何对象的大小必须是8字节的整数倍，对象头已经精心设计为8字节的倍数了，因此，对象实例数据部分没有对齐的话，就需要通过对齐填充来补全
3. 对象的访问定位
   - Java程序通过栈上的引用数据来操作堆上的具体数据
   - 《Java虚拟机规范》中，引用类型只规定了它是一个指向对象的引用，并没有定义这个引用应该通过什么方式去定位、访问堆中对象的具体位置，所以，对象的访问方式也是根据虚拟机的实现而定的
   - 主流的访问方式
     - 句柄
       - 会从堆中划分一块内存作为句柄池，引用存放对象的句柄地址
       - 句柄中包含对象实例数据与类型数据各自的具体地址信息
       - ![image-20220316155755694](https://gitee.com/qianchao_repo/pic-typora/raw/master/img/image-20220316155755694.png)
     - 直接指针 
       -  HotSpot采用此种方式
       - 引用直接存放堆中对象的地址，且这个对象中存放着类型数据的地址指针
       - ![image-20220316155903853](https://gitee.com/qianchao_repo/pic-typora/raw/master/img/image-20220316155903853.png)

---

### 垃圾收集器与内存分配策略

#### 对象已死？

垃圾收集器在对堆进行回收前，第一件事情是确定这些对象是否还存活着

##### 引用计数法

1. 判断对象是否存活的算法：在对象中添加一个引用计数器，每当有地方引用它时，计数器就加一；当引用失效时，计数器减一；任何时刻计数器为零的对象就是不可能在被使用的
2. 主流的JVM都没有采用此算法来管理内存
3. 缺点：很难解决对象之间相互循环引用的问题

##### 可达性分析算法

1. 通过一系列称为 GC Roots 的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为"引用链"，如果某个对象到GC Roots没有任何引用链相连==》从GC Roots到这个对象不可达时，则证明此对象是不可能在被使用的
2. Java体系中，可固定作为GC Roots的对象包括
   - 虚拟机栈（栈帧中的局部变量表）中引用的对象 例如：各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等
   - 方法区中类静态属性引用的对象、常量引用的对象
   - 本地方法栈中引用的对象
   - Java虚拟机内部的引用，如：基本数据类型对应的Class对象，一些常驻的异常对象，系统类加载器等
   - 所有被同步锁持有的对象

##### 再谈引用

判断对象是否存活，都和引用离不开关系。因为引用指向着对象

1. 强引用
   - 程序中普遍存在的引用，类似：Object o=new Object()
   - 只要强引用关系还存在，那么GC就永远不会回收掉被引用的对象
2. 软引用
   - 描述一些还有用，但是非必须的对象
   - 只被软引用关联的对象，系统发送内存溢出前，会把这些对象列入回收范围之中进行第二次回收，如果这次回收还没有足够的内存，那么才会抛出内存溢出异常
3. 弱引用
   - 也是用来描述那些非必须对象，但是它的强度比软引用更弱一些
   - 被弱引用关联的对象只能生存到下一次垃圾收集发生为止。当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。
4. 虚引用
   - 一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例
   - 为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知

##### 生存还是死亡

1. 被判定为不可达对象，并非非死不可，要真正宣告一个对象死亡，至少要经过两次标记过程
   - 没有到达GC Roots的引用链，被第一次标记
   - 随后，进行一次筛选，看此对象是否有必要执行finalize()方法。如果对象没有覆盖此方法，或者此方法已经被虚拟机调用了，那么虚拟机视为不必要执行
   - 若为有必要执行finalize()方法。。。
   - finalize方法是对象逃脱死亡的最后一次机会，如果对象要在这finalize()方法中成功拯救自己--只要重新与引用链上的任意对象建立联系即可。如果对象不在这时候逃脱，那么基本上就是真的回收了

##### 回收方法区

方法区的垃圾收集主要两部分内容

1. 废弃的常量
2. 不再使用的类型

---



#### 垃圾收集算法

##### 引用计数式垃圾收集    也叫直接垃圾收集

1. 主流Java虚拟机中均未涉及

###### 追踪式垃圾收集           也叫间接垃圾收集



##### 分代收集理论

1. 弱分代假说
   - 大多数对象都是朝生夕灭的
2. 强分代假说
   - 熬过越多次垃圾收集过程的对象越消亡
3. 跨代引用假说
   - 跨代引用相对于同代引用来说仅占极少数

分代假说共同奠定了多款垃圾收集器的一致设计原则

1. 收集器将Java堆划分不同的区域
2. 将回收对象依据年龄分配到不同的区域中存储   年龄：对象熬过垃圾收集过程的次数

根据分代理论现代JVM一般至少将Java堆划分为

1. 新生代 Young Generation
   - 每次垃圾收集时都发现有大批对象死去，而每次回收后存活的少量对象，将会逐步晋升到老年代中存放
2. 老年代 Old Generation

GC分类

1. 部分收集Partial GC

   - 指目标不是完整收集整个Java堆的垃圾收集

   - 新生代收集Minor GC/Young GC：收集目标只是新生代的垃圾收集

   - 老年代收集Major GC/Old GC：指目标只是老年代的垃圾收集、目前只有CMS收集器会有单 

     独收集老年代的行为

   - 混合收集 Mixed GC：指目标是收集整个新生代以及部分老年代的垃圾收集。目前只有G1收 

     集器会有这种行为

2. 整堆收集 Full GC

   - 收集整个Java堆和方法区的垃圾收集

##### 标记-清除算法

1. 首先标记出所有需要回收的对象，标记完成后，统一回收掉所有被标记的对象
2. 标记过程就是对象是否属于垃圾的判定过程
3. 缺点
   - 执行效率不稳定，如果Java堆中有大量对象，而且大部分都是需要回收的，这时必须进行大量标记和清除动作，这个过程随着对象的增多效率降低
   - 内存空间碎片化问题，标记、清除会产生大量不连续的内存碎片，空间碎片太多，可能导致程序运行过程中需要分配较大对象时，无法找到足够连续的内存，而不得不提前触发一次垃圾收集动作
4. ![image-20211217141244716](https://gitee.com/qianchao_repo/pic-typora/raw/master/img/image-20211217141244716.png)

##### 标记-复制算法 

1. 又称复制算法，为解决标记-清楚算法面对大量可回收对象时执行效率低的问题
2. 半区复制算法
3. 将可用内存按容量划分大小相等的两块，每次只使用其中的一块
4. 当一块内存用完了，就将还存活的对象复制到另一块上，然后把已经使用过的内存空间一次清理掉
5. 缺点
   - 可用内存缩小为原来的一般，空间浪费太多
6. 现代大多数JVM都采用此种收集算法**来回收新生代**
   - 新生代中的对象98%都熬不过第一轮回收，所以并不需要按照1：1的比例来划分新生代的内存空间
   - 针对这种对象的特点，提出了一种半区复制分代策略，称为"Appel式回收"，HotSpot VM 的Serial、ParNew等新生代收集器均使用此种策略来设计新生代的内存分布
   - 具体做法
     - 把新生代分为一块较大的Eden空间和两块较小的Survivor空间，每次分配内存只使用Eden和Survivor其中的一块，即：新生代空间==》Eden:Survivor:Survivor  8:1:1  
     - 当发生垃圾收集时，将Eden和Survivor中仍存活的对象一次性复制到另一块Survivor空间上，然后清理掉Eden和Survivor的空间
     - HotSpot VM 默认Eden和Survivor大小比例为8：1，即：每次新生代中**可用空间**为整个新生代容量的90%
     - 因为不能保证100%每次回收都只要不多于10%的对象存活，所以还得设计一个当Survivor空间不足以容纳一次Minor GC（针对新生代回收）之后存活的对象时，需要依赖其他内存区域（大多是老年代）进行分配担保
     - Survivor空间没有足够空间存放上一次新生代收集下来的存活对象，这些对象便将通过分配担保机制直接进入老年代
7. ![image-20211217142110952](https://gitee.com/qianchao_repo/pic-typora/raw/master/img/image-20211217142110952.png)

##### 标记-整理算法

1. 针对老年代存亡特征而设计
2. 先标记需要回收的对象
3. 让所有存活的对象向内存空间一端移动，然后直接清理掉边界以外的内存
4. 与标记-清除算法区别
   - 清除算法是一种非移动式的回收算法
   - 整理是移动式的
5. ![image-20211217150553381](https://gitee.com/qianchao_repo/pic-typora/raw/master/img/image-20211217150553381.png)

#### HotSpot的算法细节实现

---

#### 经典垃圾收集器

![image-20211217151616114](https://gitee.com/qianchao_repo/pic-typora/raw/master/img/image-20211217151616114.png)

1. Serial收集器   采用标记-复制算法

   - 当它进行垃圾收集时，必须暂停其他所有工作线程，直到它收集结束
   - 当时这项工作是虚拟机后台自动发起和完成的
   - 迄今为止，它依然是HotSpot虚拟机运行在客户端模式下的默认新生代收集器

2. ParNew收集器   采用标记-复制算法

   - 实际是Serial收集器的多线程并行版本

3. Parallel Scavenge收集器   采用标记-复制算法

   - 关注点：达到一个可控制的吞吐量
   - 吞吐量：运行用户代码时间 / 运行用户代码时间+运行垃圾收集时间

4. Serial Old收集器   采用标记-整理算法

   - Serial的老年代版本
   - 主要意义：提供客户端模式下的HotSpot VM使用
   - 服务端模式意义
     - JDK5以及之前与Parallel Scavenge收集器搭配使用
     - 作为CMS收集器发生失败时的后备预案

5. Parallel Old收集器 采用标记-整理算法

6. CMS收集器  Concurrent Mark Sweep   基于标记-清除算法

   - 一种以获取最短回收停顿时间作为目标的收集器
   - 运作过程包含四步
   - 初始标记
     - 标记GC Roots能直接关联到的对象 
   - 并发标记
     - 从GC Roots的直接关联对象开始遍历整个对象图的过程
   - 重新标记
     - 修正并发标记期间，因用户程序继续运作儿导致标记产生变动的那一部分对象的标记记录
   - 并发清除
     - 清理删除掉标记阶段判断的已经死亡的对象，由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的

7. Garbage First收集器  G1

   - 主要面向服务端应用的垃圾收集器

   - 它面向堆内存任意部分来组成回收集进行回收，衡量标准不再是它属于哪个分代，而是哪块内存中存放的垃圾数量最多，回收利益最大，这就是G1收集器的Mixed GC模式

   - G1开创了基于Region的堆内存布局是实现这个目标的关键

   - 虽然G1也仍是遵循分代收集理论设计的，但其堆内存的布局与其他收集器有非常明显的差异

   - G1不再坚持固定大小以及固定数量的分代区域划分，而是把连续的Java堆划分为多个大小相等的独立区域（Region），每一个Region都可以根据需要，扮演新生代的Eden空间、Survivor空间，或者老年代空间

   - 收集器能够对扮演不同角色的Region采用不同的策略去处理，这样无论是新创建的对象还是已经存活了一段时间、熬过多次收集的旧对象都能获取很好的收集效果

   - Region中还有一类特殊的Humongous区域，专门用来存储大对象。G1认为只要大小超过了一个Region容量一半的对象即可判定为大对象。每个Region的大小可以通过参数-XX：G1HeapRegionSize设定，取值范围为1MB～32MB，且应为2的N次幂。而对于那些超过了整个Region容量的超级大对象，将会被存放在N个连续的Humongous Region之中，G1的大多数行为都把Humongous Region作为老年代的一部分来进行看待

   - G1收集器的运作过程

   - 初始标记

     - 标记GC Roots能直接关联到的对象，并且修改TAMS 指针的值，让下一阶段用户线程并发运行时，能正确地在可用的Region中分配新对象

   - 并发标记

     - 从GC Root开始对堆中对象进行可达性分析，递归扫描整个堆 

       里的对象图，找出要回收的对象

   - 最终标记

     - 对用户线程做另一个短暂的暂停，用于处理并发阶段结束后仍遗留 下来的最后那少量的SATB记录

   - 筛选回收

     - 负责更新Region的统计数据，对各个Region的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个Region构成回收集，然后把决定回收的那一部分Region的存活对象复制到空的Region中，再清理掉整个旧Region的全部空间。这里的操作涉及存活对象的移动，是必须暂停用户线程，由多条收集器线程并行 完成的



---

#### 低延迟垃圾收集器

1. Shenandoa
2. ZGC

---



#### 选择合适的垃圾收集器

#### 实战：内存分配与回收策略

---







### JVM性能监控、故障处理工具

---

### JVM调优

为什么需要调优：减少GC，特别是FullGC



---

---

---

## 虚拟机执行子系统

### 类文件结构

1. Class文件是Java虚拟机执行引擎的数据入口

#### 无关性基石

1. 并非只有Java是运行在Java虚拟机上面的。例如：Kotlin、Groovy、JRuby、Scala等
2. 实现语言无关性的基础是**虚拟机和字节码存储格式**
3. Java虚拟机不与任何程序语言绑定，而只与"Class文件"这种特定的二进制文件格式关联
4. Class文件中包含了JVM指令集、符号表以及其他若干辅助信息
5. ![image-20211217173127295](https://gitee.com/qianchao_repo/pic-typora/raw/master/img/image-20211217173127295.png)

#### Class类文件的结构

1. 任何一个Class文件都对应着一个类或接口的定义信息，但是，类或接口并不一定都得定义在文件里（类或接口可以动态生成，直接送入类加载器中）
2. Class文件是一个以8个字节为基础单位的二进制流，当遇到占用8个字节以上空间的数据项时，会按照高位在前的方式分割成若干个8个字节进行存储
3. 文件格式：类似C语言结构体的伪结构来存储数据，伪结构中只有两种数据类型
   - 无符号数
     - 属于基本的数据类型
     - 以u1、u2、u4、u8来分别代表1、2、4、8个字节的无符号数
     - 无符号数可以用来描述数字、索引引用、数量值、按照UTF8编码构成的字符串值
   - 表
     - 由多个无符号数或者其他表作为数据项构成的复合数据类型
     - 所有表的命名都习惯性地以“_info”结尾
     - 表用于描述有层次关系的复合结构的数据，整个Class文件本质上也可以视作是一张表
4. Class文件的存储格式是严格限定的，各个数据项都有具体的含义
5. 下图为Class文件格式：
6. ![image-20211220103839235](https://gitee.com/qianchao_repo/pic-typora/raw/master/img/image-20211220103839235.png)

##### 魔数与Class文件版本

1. 每个Class文件的头4个字节被称为魔数，它的唯一作用：确定这个文件是否为一个能被虚拟机接收的Class文件

   

2. | 类型 | 名称          | 数量 | 解释                                                         |                          |
   | ---- | ------------- | ---- | ------------------------------------------------------------ | ------------------------ |
   | u4   | magic         | 1    | Class文件的魔数值为：0xCAFEBABE   cafebabe   Java商标咖啡杯的由来 |                          |
   | u2   | minor_version | 1    | Class文件版本号：次版本号                                    | Java的版本号是从45开始的 |
   | u2   | major_version | 1    | 主版本号                                                     |                          |

##### 常量池

1. 常量池可以比喻为Class文件里的资源仓库，它是Class文件结构中与其他项目关联最多的数据

2. | 类型    | 名称                | 数量                  | 解释                                                         |
   | ------- | ------------------- | --------------------- | ------------------------------------------------------------ |
   | u2      | constant_pool_count | 1                     | 因为常量是不固定的，所以设置一个u2类型的常量池容量计数器，容量计数从1开始。Class文件结构中只有常量池的容量计数是从1开始，对于其他集合类型，包括接口索引集合、字段表集合、方法表集合等的容量计数都与一般习惯相同，是从0开始。 |
   | cp_info | constant_pool       | constant_pool_count-1 |                                                              |

3. 常量池中主要存放两大类常量

   - 字面量：接近Java语言层面的常量概念，例如：文本字符串、声明为final的常量值等等
   - 符号引用：属于编译原理方面的概念，主要包括几类常量：
     - 被模块导出或者开发的包=>package
     - 类和接口的全限定名
     - 字段的名称和描述符
     - 方法的名称和描述符
     - 方法句柄和方法类型
     - 动态调用点和动态常量

4. 在Class文件中不会保存各个方法、字段最终在内存中的布局信息，这些字段、方法的符号引用不经过虚拟机在运行期转换的话是无法得到真正的内存入口地址，也就无法直接被虚拟机使用的。当虚拟机做类加载时，将会从常量池获得对应的符号引用，再在类创建时或运行时解析、翻译到具体的内存地址之中

##### 访问标识

1. | 类型 | 名称        | 数量 | 解释                                                         |
   | ---- | ----------- | ---- | ------------------------------------------------------------ |
   | u2   | access_flag | 1    | 识别一些类或接口层次的访问信息，包括：这个Class是类还是接口；是否定义为public类型；是否定义为abstract constant_pool_count-1 |

2. access_flag一共有16个标志位可以使用，没有使用到的标志位要求一律为0

3. | 标志名称       | 标志值 | 含义                           |      |
   | -------------- | ------ | ------------------------------ | ---- |
   | ACC_PUBLIC     |        | 是否为public                   |      |
   | ACC_FINAL      |        | 是否被声明为final              |      |
   | ACC_SUPER      |        | 是否为                         |      |
   | ACC_INTERFACE  |        | 标识这是一个接口               |      |
   | ACC_ABSTRACT   |        | 是否为abstract类型的           |      |
   | ACC_SYNTHEITIC |        | 标识这个类并非由用户代码产生的 |      |
   | ACC_ANNOTATION |        | 标识这是一个注解               |      |
   | ACC_ENUM       |        | 标识这是一个枚举               |      |
   | ACC_MODULE     |        | 标识这是一个模块               |      |

##### 类索引、父类索引与接口索引集合

1. | 类型 | 名称             | 数量             | 解释 |
   | ---- | ---------------- | ---------------- | ---- |
   | u2   | this_class       | 1                |      |
   | u2   | super_class      | 1                |      |
   | u2   | interfaces_count | 1                |      |
   | u2   | interfaces       | interfaces_count |      |

2. 类索引：this_class

   - 用于确定这个类的全限定名

3. 父类索引：super

   - 用于确定这个类的父类的全限定名
   - 除了Object外，所有的Java类都有父类，所有Java类的父类索引不为0

4. 接口索引集合：interfaces

   - 描述这个类实现了哪些接口

5. Class文件由这三项数据来确定该类型的继承关系

##### 字段表集合

1. 描述接口或者类中声明的变量
2. Java语言中的“字段”（Field）包括类级变量以及实例级变量，但不包括在方法内部声明的局部变量

##### 方法表集合

##### 属性表集合

1. Class文件、字段表、方法表都可以携带自己的属性表集合，以描述某些场景专有的信息
2. 存放：方法里面的Java代码，经过Javac编译器编译成字节码后存放在此

----

#### 字节码指令简介-

这块还没有看，后期再看

---

#### 公有设计私有实现

这块还没有看，后期再看

---

#### Class文件结构的发展

这块还没有看，后期再看

---

---

---

### 虚拟机类加载机制

1. 虚拟机如何加载Class文件？
2. Class文件进入虚拟机后发生什么变化？
3. 虚拟机类加载机制：JVM把Class文件加载到内存，并对数据进行校验、转换分析和初始化，最终形成可以被虚拟机直接使用的Java类型，这个过程就是类的加载机制

#### 类加载的时机

1. 一个类型(Class)从被加载到JVM内存中开始，到卸载出内存为止，它的整个生命周期会经历：加载、验证、准备、解析、初始化、使用、卸载

2. 验证、准备、解析统称为连接

3. 加载、验证、准备、初始化和卸载这五个阶段的顺序是确定的，类型的加载过程必须按照这种顺序按部就班地**开始**，而**解析阶段则不一定**：它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定特性（也称为动态绑定或晚期绑定）

4. 对于初始化阶段，《Java虚拟机规范》严格规定了**有且只有六种情况必须立即对类进行"初始化"**（加载、验证、准备这些阶段自然需要在此之前开始）

   - 遇到new、getstatic、putstatic、invokestatic这四条字节码指令时，如果类型没有进行过初始化，则需要先触发初始化阶段

     - 能够生成这4条指令的典型Java代码场景：
     - 使用new关键字实例化对象
     - 读取或设置一个类型的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外）。对于静态字段，只有直接定义这个字段的类才会被初始化，因此通过其子类来引用父类中定义的静态字段，只会触发父类的初始化而不会触发子类的初始化
     - 调用一个类型的静态方法的时候

   - 使用java.lang.reflect包的方法对类型进行反射调用的时候，如果类型没有进行过初始化，则需要先触发其初始化

   - 初始化类的时候，如果发现父类还没有初始化，则先初始化父类

   - 当虚拟机启动时，用户指定一个要执行的主类，虚拟机会先初始化这个类

   - 新加入的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果为REF_getStatic、REF_putStatic、REF_invokeStatic、REF_newInvokeSpecial四种类型的方法句柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化

   - 当一个接口中定义了JDK 8新加入的默认方法（被default关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化

   - ~~~java
     //被动引用的例子
     public class SuperClass { 
     	static { 
             System.out.println("SuperClass init!"); 
     	}
      	public static int value = 123; 
         public static final String HELLO="hello world";
     }
     public class SubClass extends SuperClass { 
         static { 
             System.out.println("SubClass init!"); 
         }
     }
     /*** 非主动使用类字段演示 **/ 
     public class NotInitialization { 
         public static void main(String[] args) { 
             System.out.println(SubClass.value); //通过子类引用父类的静态字段，不会导致子类初始化
             SuperClass[] sca = new SuperClass[10];//通过数组定义来引用类，不会触发此类的初始化
             System.out.println(SuperClass.HELLO);// 常量在编译阶段会存入调用类的常量池中，本质上没有直接引用到定义常量的类，因此不会触发定义常量的 类的初始化
         } 
     }
     ~~~

5. 接口也有初始化过程，这点与类是一致的，上面的代码都是用静态语句块“static{}”来输出初始化信息的，而接口中不能使用“static{}”语句块，但编译器仍然会为接口生成“<clinit>()”类构造器[2]，用于初始化接口中所定义的成员变量。接口与类真正有所区别的是前面讲述的六种“有且仅有”需要触发初始化场景中的第三种：当一个类在初始化时，要求其父类全部都已经初始化过了，但是一个接口在初始化时，并不要求其父接口全部都完成了初始化，只有在真正使用到父接口的时候（如引用接口中定义的常量）才会初始化

#### 类加载的过程

1. 全过程：加载、验证、准备、解析、初始化

##### 加载

1. 加载是整个"类加载"过程的一个阶段，加载阶段，Java虚拟机需要完成三件事情
   - 通过类的全限定名来获取定义此类的二进制字节流 
     - 它并没有指明二进制字节流必须得从某个Class文件中获取，确切地说是根本没有指明要从哪里获取、如何获取。
     - 仅仅这一点空隙，Java虚拟机的使用者们就可以在加载阶段搭构建出一个相当开放广阔的舞台，Java发展历程中，充满创造力的开发人员则在这个舞台上玩出了各种花样，许多举足轻重的Java技术都建立在这一基础之上，例如
     - 从ZIP压缩包中读取，这很常见，最终成为日后JAR、EAR、WAR格式的基础。 
     - 从网络中获取，这种场景最典型的应用就是Web Applet。 
     - 运行时计算生成，这种场景使用得最多的就是动态代理技术，在java.lang.reflect.Proxy中，就是用了ProxyGenerator.generateProxyClass()来为特定接口生成形式为“*$Proxy”的代理类的二进制字节流。 
     - 由其他文件生成，典型场景是JSP应用，由JSP文件生成对应的Class文件。 
     - 从数据库中读取，这种场景相对少见些，例如有些中间件服务器（如SAP Netweaver）可以选择把程序安装到数据库中来完成程序代码在集群间的分发。 
     - 可以从加密文件中获取，这是典型的防Class文件被反编译的保护措施，通过加载时解密Class文件来保障程序运行逻辑不被窥探。 
     - 。。。。。。。。。
   - 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
   - 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区中这个类的各种数据的访问入口
2. 相对于类加载过程的其他阶段，非数组类型的加载阶段（准确地说，是加载阶段中获取类的二进制字节流的动作）是开发人员可控性最强的阶段
3. 加载阶段既可以使用Java虚拟机里内置的引导类加载器来完成，也可以由用户自定义的类加载器去完成，开发人员通过定义自己的类加载器去控制字节流的获取方式（重写一个类加载器的findClass()或loadClass()方法），实现根据自己的想法来赋予应用程序获取运行代码的动态性。
4. 对于数组类而言，情况就有所不同，数组类本身不通过类加载器创建，它是由Java虚拟机直接在内存中动态构造出来的
5. 但数组类与类加载器仍然有很密切的关系，因为数组类的元素类型（ElementType，指的是数组去掉所有维度的类型）最终还是要靠类加载器来完成加载
6. 加载阶段结束后，Java虚拟机外部的二进制字节流就按照虚拟机所设定的格式存储在方法区之中 了，方法区中的数据存储格式完全由虚拟机实现自行定义，《Java虚拟机规范》未规定此区域的具体数据结构。类型数据（类元数据）妥善安置在方法区之后，会在Java堆内存中实例化一个java.lang.Class类的对象，这个对象将作为程序访问方法区中的类型数据的外部接口
   - Class对象是存放在堆区的，不是方法区，这点很多人容易犯错。类的元数据（元数据并不是类的Class对象！Class对象是加载的最终产品，类的方法代码，变量名，方法名，访问权限，返回值等等都是在方法区的）才是存在方法区的
   - 这个Class对象除了描述对于类之外，还可以生成对象（Java反射的概念）
   - 这个Class对象并不是我们平时new Obj这样的对象
7. 加载阶段与连接阶段的部分动作（如一部分字节码文件格式验证动作）是交叉进行的，加载阶段 尚未完成，连接阶段可能已经开始，但这些夹在加载阶段之中进行的动作，仍然属于连接阶段的一部分，这两个阶段的开始时间仍然保持着固定的先后顺序。

##### 验证

1. 验证是连接阶段的第一步，目的是确保Class文件的字节流中包含的信息符合《Java虚拟机规范》的全部约束要求，保证这些信息被当作代码运行后不会危害虚拟机自身的安全
2. Class文件并不一定只能由Java源码编译而来，所以验证字节码的JVM保护自身的一项必要措施
3. 验证阶段大致完成四个阶段的检验动作
   - 文件格式验证
     - 验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理
     - 主要目的：保证输入的字节流能正确解析并存储与方法区之内，格式上符合描述一个Java类型信息的要求
     - 只有通过了这个阶段的验证，字节流才被允许进入Java虚拟机内存的方法区中进行存储
     - 后续的三个验证，全是基于方法区的存储结构上进行的，不会再直接读取、操作流
   - 元数据验证
     - 对字节码描述的信息进行语义分析，以保证其描述的信息符合《Java语言规范》的要求
     - 主要验证点：这个类是否有父类；是不是抽象类，是否实现其父类或接口的所以方法；。。。。。
     - 主要目的：对类的元数据信息进行语义分析，保证不存在与《Java语言规范》中定义相悖的元数据信息
   - 字节码验证
     - 最复杂的一个验证阶段
     - 主要目的：通过数据流分析和控制流分析，确定程序语义是合法的、符合逻辑的
   - 符号引用验证
     - 符号引用验证可以看作是对类自身以外（常量池中的各种符号引用）的各类信息进行匹配性校验，通俗来说就是，该类是否缺少或者被禁止访问它依赖的某些外部类、方法、字段等资源

##### 准备

1. 准备阶段是正式为类中定义的变量（静态变量）分配内存并设置类变量初始化的阶段

2. JDK8后，类变量随着Class对象一起放在Java堆中

3. 准备阶段，进行内存分配的仅仅包括类变量，不包括实例变量。实例变量会在对象实例化时随着对象一起分配在Java堆中

4. ~~~java
   //准备阶段value=0
   //因为这时候尚未开始执行任何Java方法，而把value设置为123的putstatis指令时程序编译后，存放于构造器<clinit>方法中，所以把value赋值为123的动作要到类初始化阶段才会被执行
   public static int value=123;
   
   //类初始化阶段分配内存赋值
   public int ttt;
   
   ~~~

   

##### 解析

1. 解析阶段是Java虚拟机将常量池内的符号引用替换为直接引用的过程
2. 符号引用：用一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可
3. 直接引用：可以直接指向目标的指针、相对偏移量或者能间接定位到目标的句柄
4. 解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符这7类符号引用进行，分别对应于常量池的CONSTANT_Class_info、CON-STANT_Fieldref_info、 CONSTANT_Methodref_info、CONSTANT_InterfaceMethodref_info、 CONSTANT_MethodType_info、CONSTANT_MethodHandle_info、CONSTANT_Dyna-mic_info和 CONSTANT_InvokeDynamic_info 8种常量类型

##### 初始化

1. 类的初始化是类加载过程的最后一个步骤

2. 类加载的前四个几个动作里（加载、验证、准备、解析），除了在加载阶段用户应用程序可以通过自定义类加载器的方式局部参与外，其余动作都完全由Java虚拟机来主导控制

3. 直到初始化阶段，Java虚拟机才真正开始执行类中编写的Java程序代码，将主导权移交给应用程序

4. 初始化阶段就是执行类构造器<clinit>()方法的过程，<clinit>()并不是程序员在Java代码中直接编写的方法，它是Javac编译器的自动生成物

5. ~~~java
   ·<clinit>()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static{}块）中的 语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序决定的，静态语句块中只能访问 到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访 问
   public class Test { 
       static { 
           i = 0; // 给变量复制可以正常编译通过
           System.out.print(i); // 这句编译器会提示“非法向前引用” 
       }
       static int i = 1; 
   }
   ~~~

6. <clinit>()方法与类的构造函数（虚拟机视角中的实例构造器<init>()方法）不同，它不需要显式地调用父类构造器，Java虚拟机会保证在子类的<clinit>()方法执行前，父类的<clinit>()方法已经执行完毕。因此在Java虚拟机中第一个被执行的<clinit>()方法的类型肯定java.lang.Object

7. 类的初始化和类的实例化区别

   - 初始化是类加载过程中的初始化阶段对类变量按照程序员的意图进行赋值的过程 例如：private static int value=123  =>准备阶段value=0，初始化阶段赋值为123
   - 类完全加载到内存中创建对象的过程

---

#### 类加载器 Class Loader

1. 类加载阶段通过一个类的全限定名来获取描述该类的二进制字节流的动作，这个动作可以放到Java虚拟机外部去实现，从而让应用程序自己决定如何去获取所需的类。实现这个动作的代码称为类加载器
2. 类加载器用于实现类的加载动作

##### 类与类加载器

1. **对于任意一个类**，都必须由加载它的类加载器和这个类本身一起共同确立其在Java虚拟机中的唯一性，每一个类加载器都拥有一个独立的类名称空间
2. 也就是：比较两个类是否相等，只有在这两个类是同一个类加载器加载的前提下才有意义。否则，即使这两个类来源同一个Class文件，被同一个Java虚拟机加载，只要加载他们的类加载器不同，那这两个类肯定不相等

##### 双亲委派模型

1. 从Java虚拟机角度看，只存在两种不同的类加载器

   - 启动器类加载器
     - C++实现，虚拟机自身的一部分
   - 其他所有的类加载器
     - 这些类加载器由Java实现，独立于JVM外部，并且全都继承自抽象类java.lang.ClassLoader

2. JDK8及之前都是采用三层类加载器、双亲委派的类加载架构。对于这个时期的Java应用，绝大多数Java程序都会使用到以下3个系统提供的类加载器来进行加载：3、4、5

3. 启动类加载器：Bootstrap Class Loader

   - 这个类负责加载存放在<JAVA_HOME>\lib目录或者被-Xbootlasspath参数所指定的路径中存放的，而且是Java虚拟机能够识别的（按照文件名识别，例如：rt.jar、tools.jar，名字不符合的类库即使放在lib目录也不会被加载）类库加载到虚拟机内存中

   - 启动类加载器无法被Java程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给引导类加载器去处理，那直接使用null代替即可

   - ~~~java
     //java.lang.ClassLoader.getClassLoader()方法的代码片段
     /** Returns the class loader for the class. Some implementations may use null to represent the bootstrap class loader. This method will return null in such implementations if this class was loaded by the bootstrap class loader. */
     public ClassLoader getClassLoader() { 
         ClassLoader cl = getClassLoader0(); 
         if (cl == null) return null; 
         SecurityManager sm = System.getSecurityManager(); 
         if (sm != null) { 
             ClassLoader ccl = ClassLoader.getCallerClassLoader(); 
             if (ccl != null && ccl != cl && !cl.isAncestor(ccl)) { 					sm.checkPermission(SecurityConstants.GET_CLASSLOADER_PERMISSION);
             } 
         }
         return cl; 
     }
     ~~~

4. 扩展类加载器 Extension Class Loader

   - 这个类加载器是在类sun.misc.Launcher$ExtClassLoader中以Java代码的形式实现的。它负责加载<JAVA_HOME>\lib\ext目录中，或者被java.ext.dirs系统变量所 指定的路径中所有的类库
   - 这是一种Java系统类库的扩展机制，JDK的开发团队允许用户将具有通用性的类库放置在ext目录里以扩展Java SE的功能，在JDK9之后，这种扩展机制被模块化带来的天然的扩展能力所取代
   - 由于扩展类加载器是由Java代码实现的，开发者可以直接在程序中使用扩展类加载器来加载Class文件

5. 应用程序类加载器 Application Class Loader

   - 这个类加载器由sun.misc.Launcher$AppClassLoader来实现
   - 由于应用程序类加载器是ClassLoader类中的getSystem-ClassLoader()方法的返回值，所以有些场合中也称它为“系统类加载器”
   - 它负责加载用户类路径（ClassPath）上所有的类库，开发者同样可以直接在代码中使用这个类加载器
   - **如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器**

6. 双亲委派模型

   - 各种类加载器之间的层次关系被称为：类加载器的双亲委派模型

   - JDK 9之前的Java应用都是由这三种类加载器互相配合来完成加载的，如果用户认为有必要，还可 

     以加入自定义的类加载器来进行拓展，典型的如增加除了磁盘位置之外的Class文件来源，或者通过类 

     加载器实现类的隔离、重载等功能。这些类加载器之间的协作关系“通常”会如图7-2所示

     ![image-20211222152459906](https://gitee.com/qianchao_repo/pic-typora/raw/master/img/image-20211222152459906.png)

   - 双亲委派模型要求：除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器，不过类加载器之间的父子关系一般不是以继承的关系来实现的，而是通常使用组合关系来复用父加载器的代码

   - 双亲委派模型工作过程：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去完成加载

   - 使用双亲委派模型来组织类加载器之间的关系，一个显而易见的好处就是Java中的类随着它的类加载器一起具备了一种带有优先级的层次关系。

     

##### 破坏双亲委派模型

1. 过双亲委派模型并不是一个具有强制性约束的模型，而是Java设计者推荐给开发者们的类加载器实现方式

2. JDBC、JNDI、SPI、Spring等等采用线程上下文类加载器来加载，并没有走双亲委派模型

3. 后期还需加强这块的理解

   

#### Java模块化系统

1. Java9引入的Java模块化系统(Java Platform Module System JPMS)
2. 为了能够实现模块化的关键目标--可配置的封装隔离机制，Java虚拟机对类加载器架构做出了相应的变动调整，才使得模块化系统能顺利地运作
3. 后期还需加强这块的理解

##### 模块的兼容性

##### 模块化下的类加载器

---

### 虚拟机字节码执行引擎

### 类加载及执行子系统的案例与实战



---

## 高效并发

### Java内存模型与线程

#### Java内存模型

1. 主内存与工作内存
2. 内存间交互操作
   - 主内存与工作内存直接具体的交互协议，即：一个变量如何从主内存拷贝到工作内存、如何从工作内存同步回主内存这一类的实现细节
   - Java内存模型定义了8种操作来完成。JVM实现时必须保证每一种操作都是原子的（long、double另讨论）
   - 作用于主内存的变量
     - lock锁定：把变量标识为一条线程独占的状态
     - unlock解锁：把处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定
     - read读取：把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用
   - 作用于工作内存的变量
     - load载入：把read的操作从主内存中得到的变量值放入工作内存的变量副本中
     - use使用：把变量的值传递给执行引擎，每一次需要这个变量的值时，都会执行该操作
     - assign赋值：把从执行引擎接收的值，赋值给工作内存的变量
     - store存储：把工作内存中一个变量的值传输到主内存中，以便write操作使用
     - write写入：把store操作从工作内存中得到的变量的值放入主内存的变量中
3. volatile
4. long、double类型变量的特殊规则
   - 对于64位的数据类型，允许虚拟机将没有被volatile修饰的数据的读写操作划分为两次32为操作来进行
   - 多个线程操作，极少可能会出现读取到"半个变量"的情况
5. 原子性、可见性、有序性
6. 先行发生原则happen-before

### 线程安全与锁优化















































## 面试题

### JVM的主要组成部分以及作用

- 程序执行之前，把Java代码编译为字节码文件（class文件），JVM首先需要把字节码 通过类加载器，把文件加载到运行时数据区。
- 而字节码文件是Jvm的一套指令集规范，不能直接交给底层操作系统去执行，因此需要特定的命令解析器（执行引擎）将字节码翻译成底层系统指令，再交给CPU去执行，执行过程中，需要调用其他语言的接口（本地库接口）来实现整个程序的功能

1. 类加载器
2. 运行时数据区
3. 执行引擎
4. 本地库接口

### 

---

### 堆栈区别

1. 堆和栈是完全不同的两块内存区域
2. 堆是线程共享的，堆中主要存放对象实例
3. 栈是线程私有的，栈主要存放各种基本类型数据、对象的引用

---



### Java中的参数传递时传值呢？还是传引⽤？

### **Java** 对象的⼤⼩是怎么计算的

### 对象的访问定位的两种⽅式

### 判断垃圾可以回收的⽅法有哪些

### 垃圾回收是从哪⾥开始的呢

### 被标记为垃圾的对象⼀定会被回收吗

### **谈谈对** **Java** 中引⽤的了解

### 谈谈对内存泄漏的理解

### 内存泄露的根本原因是什么

### 举⼏个可能发⽣内存泄漏的情况

**尽量避免内存泄漏的⽅法？**

常⽤的垃圾收集算法有哪些



什么是浮动垃圾？**

谈谈你对 **CMS** **垃圾收集器的理解

**G1** 收集器的理



如何利⽤监控⼯具调优





JVM的⼀些参数？**





谈谈你对类加载机制的了解



类加载各阶段的作⽤分别是什么



有哪些类加载器？分别有什么作⽤



类与类加载器的关系



**双亲委派模型的⼯作过程：**



**使⽤双亲委派模型的好处：**





怎么打破双亲委派模型



有哪些实际场景是需要打破双亲委派模型的



谈谈你对编译期优化和运⾏期优化的理解



**HotSpot** **虚拟机要使⽤解释器与编译器并存的架构？**



### Java**内存模型的理解

