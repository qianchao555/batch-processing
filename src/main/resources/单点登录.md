## 单点登录

https://developer.aliyun.com/article/636281

单点登录：Single Sign On，即SSO

在多个应用系统中，只需要登录一次，就可以访问其他相互信任的应用系统



### 普通的登录认证机制



![image-20220317223116516](https://pic-typora-qc.oss-cn-chengdu.aliyuncs.com/img/202203172231252.png)

如图所示：

我们在浏览器中访问一个应用，这个应用需要登录，我们填写完用户名和密码后，完成登录认证。

这时应用将这个登录的用户的session登录状态设置为yes，同时浏览器中写入Cookie，这个Cookie是这个用户的唯一标识。下一次访问这个应用的时候，请求中会带上这个Cookie，服务端会根据这个Cookie找到对应的Session，通过Session来判断这个用户是否登录。如果不做特殊配置，这个Cookie的名字叫做 jsessionid，值在服务端是唯一的

### 同源策略

前端领域中，跨域是指浏览器允许向服务器发送跨域请求，从而克服Ajax只能同源使用的限制

同源策略：指"协议+域名+端口"三者相同，即便两个不同的域名指向同一个ip，也是非同源

同源策略限制以下几种行为：

- Cookie、LocalStorage、和IndexDB无法读取
- DOM和JS对象无法获取
- Ajax请求不能发送

#### 跨域解决方案

1. JSONP跨域

   - jquery Ajax实现

   - Vue axios实现，第一个公司就是采用这钟方式

2. Nginx配置解决

4. 跨域资源共享（CORS)

   - CORS是一个W3C标准，全称：跨域资源共享 即Cross-origin resource sharing)。

   - 它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了Ajax只能同源使用的限制

   - CORS需要浏览器和服务器同时支持，目前所有浏览器都支持该功能

   - 浏览器将CORS跨域请求分为简单请求和非简单请求

     - 同时满足以下两个条件，就属于简单请求
       - 使用下列方法之一：head，get，post
       - 请求的Heder是：
         - Accept
         - Accept-Language
         - Content-Language
         - Content-Type: 只限于三个值：application/x-www-form-urlencoded、multipart/form-data、text/plain

   - 不同时满足上面的两个条件，就属于非简单请求。浏览器对这两种的处理，是不一样的

     - 对于简单请求，浏览器直接发出CORS请求。具体来说，就是在头信息之中，增加一个Origin字段。

       ```text
       GET /cors HTTP/1.1
       Origin: http://api.bob.com
       Host: api.alice.com
       Accept-Language: en-US
       Connection: keep-alive
       User-Agent: Mozilla/5.0...
       ```

     - 非简单请求：非简单请求是那种对服务器有特殊要求的请求，比如请求方法是PUT或DELETE，或者Content-Type字段的类型是application/json。非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为"预检"请求（preflight）

       - 预检请求：预检"请求用的请求方法是OPTIONS，表示这个请求是用来询问的。请求头信息里面，关键字段是Origin，表示请求来自哪个源。除了Origin字段，"预检"请求的头信息包括两个特殊字段。

       ```text
       OPTIONS /cors HTTP/1.1
       Origin: http://api.bob.com
       Access-Control-Request-Method: PUT   //必选 用来列出浏览器的CORS请求会用到哪些HTTP方法，上例是PUT
       Access-Control-Request-Headers: X-Custom-Header
       Host: api.alice.com
       Accept-Language: en-US
       Connection: keep-alive
       User-Agent: Mozilla/5.0..
       ```



### 同域下的单点登录

一般情况下一个企业只有一个域名，通过二级域名区分不同的系统

比如某个域名叫做：a.com，同时有两个业务系统分别为：app1.a.com和app2.a.com。我们要做单点登录，需要一个登录系统，叫做sso.a.com

只要做了sso.a.com单点登录，app1.a.com和app2.a.com也就可以自动登录了。

通过上面的登录认证机制，我们知道在sso.a.com中登录了，其实是在sso.a.com的服务端的session中记录了登录状态，同时在浏览器端的sso.a.com下写入了Cookie。那么怎么才能让app1.a.com和app2.a.com登录呢？

这里有两个问题：

- Cookie是不能跨越的，这里Cookie的domain属性是sso.a.com，在给app1和app2发送请求是带不上的
- sso、aap1、app2是不同的应用，他们的session存在自己的应用内的，是不共享的

如何解决这两个问题：

- 针对第一个问题：sso登录后，可以将Cookie的域设置为顶域，即 .a.com，这样所以子域的系统都可以访问到顶域的Cookie。在设置Cookie时，只能设置顶域和自己的域，不能设置其他域。比如：我们不能在自己的系统中给baidu.com的域设置Cookie
- 第二个session问题：在sso系统登录了，这时再访问app1，Cookie也带到了app1的服务端，app1的服务端怎么找到这个Cookie对应的session呢？这里就需要把3个应用的session共享，共享session的解决方案很多，例如：Spring-Session。这样第二个问题就解决了

![image-20220317225611854](https://pic-typora-qc.oss-cn-chengdu.aliyuncs.com/img/202203172256735.png)

这样，同域下的单点登录就实现了，但是这不是真正的单点登录



### 不同域下的单点登录

同域下的单点登录巧用了Cookie顶域的特性，但是不同域呢？不同域直接Cookie是不共享的，怎么办？

CAS流程：这个流程是单点登录的标准流程

![dcb743204f8a201be53df5338fc34affe5fa1059](https://pic-typora-qc.oss-cn-chengdu.aliyuncs.com/img/dcb743204f8a201be53df5338fc34affe5fa1059.png)

1. 用户访问app系统，app系统是需要登录的，但用户现在没有登录
2. 跳转到CAS server，即SSO登录系统。SSO系统也没有登录，弹出用户登录页面
3. 用户填写用户名、密码，SSO系统进行认证后，将登录状态写入SSO的session，浏览器中写入SSO域下的Cookie
4. SSO系统登录完成后，会生成一个ST(Service Ticket)，然后跳转到app系统，同时将ST作为参数传递给app系统
5. app系统拿到ST后，从后台向SSO发送请求，验证ST是否有效
6. 验证通过后，app系统将登录状态写入session并设置app域下的Cookie

至此，跨域单点登录就完成了，以后再访问app系统时，app系统就是登录的。接下来，看看app2系统登录时的流程

1. 用户访问app2系统，app2系统没有登录，跳转到SSO
2. 由于SSO已经登录了，不需要重新登录验证
3. SSO生成ST，浏览器跳转到app2系统，并将ST作为参数传递给app2
4. app2拿到ST，后台访问SSO，验证ST是否有效
5. 验证成功后，app2将登录状态写入session，并在app2域下写入Cookie

这样app2系统不需要走登录流程，就已经登录了。SSO、app1、app2在不同的域，它们之间的session不共享也是没问题的



### 总结

1. 单点登录(SSO系统)是保障各个业务系统的用户资源的安全
2. 各个业务系统获取到的信息是这个用户能不能访问我的资源
3. 单点登录，资源都在各个业务系统，不做SSO这边。用户在给SSO服务器提供用户名和密码后，作为业务系统并不知道这件事情。 SSO随便给业务系统一个ST，那么业务系统是不能确定这个ST是用户伪造的，还是真的有效，所以要拿着这个ST去SSO服务器再问一下，这个用户给我的ST是否有效，是有效的我才能让这个用户访问



### Token及Token验证流程

https://blog.csdn.net/qq_38796823/article/details/88207727

#### 什么是token及为什么使用它

Token：实际上就是计算机身份验证中令牌（临时）的意思。当前端向后端发送请求的时候，后端需要对前端进行身份验证，但是又不想每次都输入用户名和密码，这时就需要一个标识来证明自己的身份，这个标识就是token，服务端并不保存，只是验证token和查询用户数据

token的出现解决了session的弊端，成为session的替代品

**Session弊端**

1. 用户通过认证后session存储在服务器内存，当用户量增大时，服务器压力增加
2. 扩展性不强：想象这么一个场景，若项目在多个服务器上部署，那我再其中一台登录了，称为A，session也保存到A中，万一下次我访问到另外一台服务器B怎么办？B上没有A的session呢？为了解决这个问题，我们需要将session保存到数据库中，所以每次保存这些session信息就是一个负担了，增加了服务器的存储压力

#### 基于Token的身份验证流程

客户端使用用户名和密码请求登录
服务端收到请求，验证登录是否成功
验证成功后，服务端会返回一个Token给客户端，反之，返回身份验证失败的信息
客户端收到Token后把Token用一种方式存储起来,如( cookie / localstorage / sessionstorage / 其他 )
客户端每次发起请求时都会将Token发给服务端
服务端收到请求后，验证Token的合法性，合法就返回客户端所需数据，反之，返回验证失败的信息

![image-20220318112438616](https://pic-typora-qc.oss-cn-chengdu.aliyuncs.com/img/image-20220318112438616.png)

#### Token的特点

1. 随机性：每次的token都是不一样的
2. 不可预测性：没有规律，无法预测
3. 时效性： 可以设置token的有效时间
4. 无状态、可扩展：由于只是一个算法，后端不需要记录信息，每次请求过来进行解密就能得到对应信息，扩展起来非常方便
5. 生成Token的解决方案
   - 有许多，常用的一种就是 Json Web Tokens(JWT) 
   - OAuth

#### Token分类

针对接口的api_token

- 接口token生成规则：api_token=md5('模块名'+'控制器名'+'方法名'+'年-月-日'+'加密密钥')

针对用户的user_token

-接口token生成规则：user_token=md5('用户的uid'+'Unix时间戳')

gongsi采用：



---

### Spring Security

权限管理框架，可以做用户验证、权限管理等等

有了SpringBoot、Cloud后，Security比Shiro更具优势，也使用的更多

#### 核心功能

认证和授权

1. 认证：通俗说就是 需要登录 才能访问某个url资源

##### 认证

通俗来说就是我们常说的登录通过@EnableWebSecurity开启

SpringSecurity支持的认证方式：

- HTTP BASIC authentication headers：基于IETF RFC 标准。
- HTTP Digest authentication headers：基于IETF RFC 标准。
- HTTP X.509 client certificate exchange：基于IETF RFC 标准。
- LDAP：跨平台身份验证。
- Form-based authentication：基于表单的身份验证。
- Run-as authentication：用户用户临时以某一个身份登录。
- OpenID authentication：去中心化认证

除了这些常见的认证方式之外，一些比较冷门的认证方式，Spring Security 也提供了支持。

- Jasig Central Authentication Service：单点登录。
- Automatic "remember-me" authentication：记住我登录（允许一些非敏感操作）。
- Anonymous authentication：匿名登录。



认证可以单独使用，即不划分资源的级别，所有人只要登录都可以查看



##### 授权

即：你能干什么， 不需要通过指定的开关开启，而是通过配置来增加授权规则来生效，不增加授权规则就不生效

就是权限鉴别，看请求是否具备相应的权限，

授权的目的是可以把资源进行划分，例如公司有不同的资料，有普通级别和机密级别，只有公司高层才能看到机密级别的子类，而普通级别的资料大家都可以看到！ 那么授权就是允许你查看某个资源，当然，如果你没有权限，就拒绝你查看

SpringSecurity支持基于UPL的请求授权、支持方法访问授权以及对象访问授权



安全这一块从来都有说不完的话题，一个简单的注册登录很好做，但是你要是考虑到各种各样的攻击，XSS、CSRF 等等，一个简单的注册登录也能做的很复杂。只要你用了 Spring Security，就能自动避免掉很多攻击了，因为 Spring Security 已经自动帮我们完成很多防护了。



#### 基本原理

Spring Security核心就是一组过滤器链，采用责任链模式，项目启动后将会自动配置

将这组过滤链，加入到原生web过滤链中



#### Spring Security和Spring Security OAuth2关系

1. Spring Security是一个框架，提供了认证和授权
2. OAuth2只是一个协议，需要具体的实现
3. spring security oauth2：spring security框架中内置了oauth2，可以直接使用，当然其他框架也有实现了oauth2的



##### 用户、角色、用户-角色

SpringSecurity自带的JdbcUserDetailsManager做持久化，局限性大，一般不用它做持久化方案

Spring Security 结合Mybatis/Jpa做持久化方案，可以灵活定制用户表、角色表

主要接口：UserDetails/ UserDetailsService



---



#### 登录流程

三个基本组件AuthenticationManager、ProviderManager、AuthenticationProvider

接入认证功能的过滤器：AbstractAuthenticationProcessingFilter

##### AuthenticationManager接口

是一个认证管理器，定义了SpringSecurity过滤器要如何执行认证操作，认证成功后返回一个Authentication对象，该对象会被设置到SecurityContextHolder中。实际应用中使用最多的是ProviderManager实现类，Spring Security默认也是使用ProviderManager



##### AuthehticationProvider

SpringSecurity支持不同的认证方式，不同的认证方式对应不同的身份类型，AuthehticationProvider就是针对不同的身份类型执行具体的身份认证，身份认证就是在其authenticate(Authentication authentication)中完成的

例如：RememberMeAuthenticationProvider用来支持“记住我”类型的认证、UsernamePasswordAuthentication支持用户名/密码类型的登录认证



##### ProviderManager

ProviderManager管理各个AuthenticationProvider，不同的认证方式对应了不同的AuthenticationProvider，所以一个完整的认证流程可能由多个AuthenticationProvider来提供，多个AuthenticationProvider将组成一个列表，这个列表由ProviderManager代理，在ProviderManager中遍历列表中的每一个AuthenticationProvider去执行身份认证，最终得到认证结果

![image-20220928204400095](https://pic-typora-qc.oss-cn-chengdu.aliyuncs.com/springsecurity_img/202209282044337.png)







##### AbstractAuthenticationProcessingFilter

SpringSecurity过滤器链中的一环，它可以用来处理任何提交给它的身份认证

![image-20220928205118309](https://pic-typora-qc.oss-cn-chengdu.aliyuncs.com/springsecurity_img/202209282051415.png)



##### 认证配置多数据源

指的是用户数据来自不同的表，认证时，若第一张表没有找到用户，则在其他表中查找

分析：认证都要经过AuthenticationProvider，每一个Ap中都会配置UserDetailsService，而不同的UDS则可以代表不同的数据源，所以只需要配置多个AP，并且为不同AP配置不同的UserDetailsService即可



##### 添加登录验证码

SpringSecurity没有提供自动化配置方案，需要开发者自行定义

常用实现登录验证码的两种思路：

1. 自定义过滤器
2. 自定义认证逻辑

生成验证码：Google开源库工具kaptcha



----

#### 过滤器链分析

##### 初始化流程分析

1. **ObjectPostProcessor**

它是SpringSecurity中使用频率最高的组件之一，它是一个后置处理器，也就是当一个对象创建成功后，如果还需要一些额外的事情补充，则可以通过ObjectPostProcessor来进行处理，这个接口默认只有一个postProceess方法，该方法用来完成对对象的二次处理

![image-20220928214342403](https://pic-typora-qc.oss-cn-chengdu.aliyuncs.com/springsecurity_img/202209282143538.png)



Spring Security中采用了大量的Java配置，许多过滤器是直接new出来的，这些new出的对象不会自动注入到Spring容器中，所以采用这两个实现类来将对象注入到Spring容器中，Spring Securtiy默认采用第二种方式，该方式一个对象可以有多个后置处理器，它里面的集合默认只有一个对象就是AutowireBeanFactoryObjectPostProcessor

Spring Security中，可以灵活配置需要哪些SpringSecurity过滤器，选定过滤器后，**每一个过滤器都会有一个对应的配置器**，叫做xxxConfigurer，例如CorsConfigurer、CsrfConfigurer，过滤器都是在xxxConfigurer中new出来的，然后在postProcess方法中处理将这些过滤器注入到Spring容器中



2. **SecurityFilterChain**

   就是Spring Security中过滤器链对象

3. **SecurityBuilder**

   SpringSecurity中**所有**需要构建的对象都可以通过它来实现，默认的过滤器链、代理过滤器、AuthenticationManager等，都可以通过它来构建

   不同的SecurityBuilder会构建出不同的对象，例如AuthenticationManagerBuilder用于构建AuthenticationManager对象

4. WebSecurity

   是一在更大的层面取构建过滤器，一个HttpSecurity对象可以构建一个过滤器链，也就是一个DefaultSecurityFilterChain对象，而一个项目中可以存在多个HttpSecurity对象，也就可以构建多个DSFC过滤器链

   最终由它返回一个filterChainProxy对象，这个对象是最终构建出来的代理过滤器链，通过Spring提供的DelegatingFilterProxy将其嵌入到原生Web Filter中

5. FilterChainProxy

   SpringSecurity中的过滤器链中的最终执行，就是在FilterChainProxy中

   

##### SecurityConfigurer接口

核心方法init、configure，一个完成配置类的初始化操作，一个进行配置类的配置







#### 多个过滤器链

全局AuthenticationManager、局部AuthenticationManager

登录认证时，先调用局部，若登录不成功再调用全局，全局默认登录名为user，密码为随机uuid，全局配置可以自定义



Spring Security中可以同时存在多个过滤器链，一个WebSecurityConfigurerAdapter的实例就可以配置一条过滤器链

比如/bar/xxx 、/foo/xxx分别为这种请求构建过滤链，是/bar/xx走自己的过滤器链中进行处理



##### 静态资源过滤

实际项目中，并非所有的请求都要经过SpringSecurity过滤器，例如静态资源一般不需要经过过滤器链，用户如果访问这些静态资源，直接返回对应的资源即可

WebSecurity中有一个ignoredRequests变量，里面记录的就是所有需要被忽略的请求



##### 使用Json格式登录

SpringSecurity默认登录参数传递格式是k-v格式，也就是表单登录，实际项目中，一般使用Json格式来传递登录参数，这就需要自定义过滤器来实现

---

#### 密码加密

实际项目中，密码等重要信息都会采用密文进行存储，若用明文存储会带来极高的安全风险。企业级应用中，密码不仅要加密还会采用加盐来保证密码的安全性

传统加密方式：将明文进行Hash运算(例如：SHA-256等等)得到密文进行存储

##### 彩虹表

是一个用于对加密Hash函数逆运算的表，通常用于破解加密过的Hash字符串，为了降低彩虹表对系统安全性的影响，人们又发明了密码加盐，即：对明文加密后，再添加一个随机数(即盐)和密文再混合在一起进行加密，这样即使明文相同，生成的加密字符串也是不同的，当然这个随机数也需要以明文方式和密文一起存放数据库的

用户登录：将输入的明文和存储再数据库中的盐一起进行Hash，再将运算结果和存储在数据库中的密文进行比较，进而确定用户的登录信息是否有效

但是：随着计算机硬件发展，每秒执行数十亿次Hash计算已经轻轻松松了，这意味着即使给密码加密加盐也不再安全

SpringSecurity采用了一种**自适应单向函数**来处理密码问题，这种函数在进行密码匹配时，会刻意占用大量系统资源(例如cup、内存等)，可以增加恶意用户攻击系统的难度

SpringSecurity中可以通过bcrypt、PBKDF2、scrypt等自适应单向函数进行加密

由于自适应单向函数刻意占用大量系统资源，因此每个登录认证请求会大大降低应用程序的性能，但是SpringSecurity没有采用任何措施来提高密码验证的速度，因为它正是通过这种方式来增强系统的安全性，所以开发者可以将用户名/密码这种长期凭证兑换为短期凭证，例如：会话、OAuth2令牌等，这样既可以快速验证用户凭证信息，又不会损失系统安全性。通常也是会采用token方式来登录验证



---

### 令牌与密码

1. 令牌(token)是短暂的，到期后会自动失效，用户无法自己修改。密码一般长期有效，用户不修改就不会发生变化
   - 因为知道了令牌就能进入系统，系统一般不会进行二次验证，所有令牌必须保密，令牌泄露和密码泄露后果是一样的
   - 所以一般需要设置有效期
   
2. 令牌可以被数据所有者撤销，会立即失效

3. 令牌有权限范围，密码一般是完整权限

   

---



### OAuth

Open Authority

https://blog.csdn.net/u012702547/article/details/105699777

一个验证授权的开放标准协议，所有人都有基于这个标准实现自己的OAuth，OAuth基于Https以及APIs，Service应用使用access token来进行身份验证

OAuth主要有OAuth1.0a和OAuth2.0两个版本，二者完全不同，而且不兼容。2.0是目前广泛使用的版本

#### OAuth2.0

目前流行的**授权机制**，用来授权第三方应用，获取用户数据，利用第三方系统获得资源

常用于第三方登录，例如：微信、微博、Github授权登录等等

#### Spring Social

是一个遵循OAuth协议的框架，暂不去了解

#### 为什么要有OAuth

在OAuth之前，使用用户名、密码进行身份验证，这种形式不安全。OAuth的出现就是为了解决访问资源的安全性以及灵活性。OAuth使得第三方应用对资源的访问更加安全

#### OAuth2.0中四个角色

OAuth的流程中，主要有以下四个角色

1. Client：想要访问用户的客户端，它使用OAuth来获取访问权限
2. Resouce Owner：用户拥有资源服务器上面的数据
3. Resouce Server：资源服务器，能够通过http请求进行访问，在访问时需要OAuth访问令牌。受保护资源需要验证收到的令牌，并决定是否响应以及如何响应请求
4. Authorization Server：授权服务器，一个HTTP服务器，OAuth的主要引擎。授权服务器对资源拥有者和客户端进行身份认证，让资源拥有者向客户端授权，为客户端颁发令牌。

例如：假设你使用了一个照片云存储服务和一个云打印服务，并且想使用云打印服务来打印存放在云存储服务上的照片。很幸运，这两个服务能够使用API 来通信。这很好，但两个服务由不同的公司提供，这意味着你在云存储服务上的账户和在云打印服务上的账户没有关联。使用OAuth 可以解决这个问题：授权云打印服务访问照片，但并不需要将存储服务上的账户密码交给它。
在这上面这一段中：
客户端 ： 云打印服务
资源拥有者：你
资源服务器，授权服务器：照片云存储服务

![image-20220319190248139](https://pic-typora-qc.oss-cn-chengdu.aliyuncs.com/img/202203191902399.png)





#### OAuth2.0四种授权模式

OAuth2.0对于如何颁发令牌的细节，规定的很细，一共分为四种授权类型即：四种颁发令牌的方式，适用于不同的场景

##### 授权码模式

常见的第三方平台登录功能基本都是使用这种模式，是最安全并且使用最广泛的一种模式

授权码模式中分为授权服务器和资源服务器，授权服务器用来分派Token、拿着Token则可以去资源服务器获取资源，这两个服务器可以分开也可以合并



##### 简化模式

简化模式是：不需要客户端服务器参与，直接在浏览器中向授权服务器申请令牌，一般如果网站是纯静态页面可以采用这种方式

##### 密码模式

密码模式是用户把用户名密码直接告诉客户端，客户端使用说这些信息向授权服务器申请令牌（token）。这需要用户对客户端高度信任，**例如客户端应用和服务提供商就是同一家公司，我们自己做前后端分离登录就可以采用这种模式**

密码模式在SpringCloud项目中广泛应用

密码模式有一个前提就是你高度信任第三方应用，举个不恰当的例子：如果我要在 www.javaboy.org 这个网站上接入微信登录，我使用了密码模式，那你就要在 www.javaboy.org 这个网站去输入微信的用户名密码，这肯定是不靠谱的，所以密码模式需要你非常信任第三方应用

密码模式的流程：

密码式的流程比较简单：

假如www.javabay.org这个网站要接入微信授权登录

首先 www.javaboy.org 会发送一个 post 请求，类似下面这样的：

```
https://wx.qq.com/oauth/authorize?response_type=password&client_id=javaboy&username=江南一点雨&password=123
```

response_type 的值这里是 password，表示密码式，另外多了用户名/密码参数，没有重定向的 redirect_uri ，因为这里不需要重定向。

微信校验过用户名/密码之后，直接在 HTTP 响应中把 令牌 返回给客户端。



##### 客户端模式

客户端模式是指客户端使用自己的名义而不是用户的名义向服务提供者申请授权，严格来说，客户端模式并不能算作 OAuth 协议要解决的问题的一种解决方案，但是，对于开发者而言，在一些前后端分离应用或者为移动端提供的认证授权服务器上使用这种模式还是非常方便的

---



#### OAuth2.0令牌存放

##### 令牌存在哪里

![image-20220319202813566](https://pic-typora-qc.oss-cn-chengdu.aliyuncs.com/img/202203192028725.png)

1. InMemoryTokenStore 内存中，也是系统默认的，不推荐
2. jdbcTokenStore 保持到数据库中
3. JwtTokenStore 这个其实不是存储，因为使用了 jwt 之后，在生成的 jwt 中就有用户的所有信息，服务端不需要保存，这也是无状态登录
4. RedisTokenStore，这个就是将 access_token 存到 redis 中
   - access_token 这个 key 在 Redis 中的有效期就是授权码的有效期。正是因为 Redis 中的这种过期机制，让它在存储 access_token 时具有天然的优势
5. JwkTokenStore，将 access_token 保存到 JSON Web Key

**掌握2、3、4**



#### OAuth2.0结合JWT

https://mp.weixin.qq.com/s/xEIWTduDqQuGL7lfiP735w

传统的通过 session 来记录用户认证信息的方式我们可以理解为这是一种有状态登录，而 JWT 则代表了一种无状态登录

#####  什么是有状态

有状态服务，即服务端需要记录每次会话的客户端信息，从而识别客户端身份，根据用户身份进行请求的处理，典型的设计如 Tomcat 中的 Session。例如登录：用户登录后，我们把用户的信息保存在服务端 session 中，并且给用户一个 cookie 值，记录对应的 session，然后下次请求，用户携带 cookie 值来（这一步有浏览器自动完成），我们就能识别到对应 session，从而找到用户的信息。这种方式目前来看最方便，但是也有一些缺陷，如下：

- 服务端保存大量数据，增加服务端压力
- 服务端保存用户状态，不支持集群化部署

##### 什么是无状态

微服务集群中的每个服务，对外提供的都使用 RESTful 风格的接口。而 RESTful 风格的一个最重要的规范就是：服务的无状态性，即：

- 服务端不保存任何客户端请求者信息
- 客户端的每次请求必须具备自描述信息，通过这些信息识别客户端身份

那么这种无状态性有哪些好处呢？

- 客户端请求不依赖服务端的信息，多次请求不需要必须访问到同一台服务器
- 服务端的集群和状态对客户端透明
- 服务端可以任意的迁移和伸缩（可以方便的进行集群化部署）
- 减小服务端存储压力

#####  如何实现无状态

无状态登录的流程：

- 首先客户端发送账户名/密码到服务端进行认证
- 认证通过后，服务端将用户信息加密并且编码成一个 token，返回给客户端
- 以后客户端每次发送请求，都需要携带认证的 token
- 服务端对客户端发送来的 token 进行解密，判断是否有效，并且获取用户登录信息



授权服务器颁发令牌后，客户端拿着令牌去请求资源服务器，资源服务器回去校验令牌的真伪。与JWT结合，实际上令牌就不要存储了（无状态登录，服务端不需要保存信息），因为用户的所有信息都在jwt里面



---

承接上OAuth2，token默认是明文不安全，采用JWT进行加密更安全

### JWT：Json Web Tokens

Jwt其实是一种广泛使用的token，他通过数字签名的方式，以JSON为载体，在不同的服务终端之间安全的传输信息

是一种 JSON 风格的轻量级的授权和身份认证规范，可实现无状态、分布式的 Web 应用授权

#### 常见应用场景

1. 授权认证，用户登录后，后续每个请求都将包含jwt，系统每次处理用户请求前，都要先进行jwt安全校验，通过校验后才能访问资源
2. 单点登录

#### JWT标准的Tokens组成

由三部分组成，这三部分使用 "."号 隔开，并且都会使用Base64编码方式编码，例如：eyJhbGc6IkpXVCJ9.eyJpc3MiOiJCIsImVzg5NTU0NDUiLCJuYW1lnVlfQ.SwyHTf8AqKYMAJc

1. header：包含token的类型和加密算法

   - ```json
     { 
       "alg": "HS256",	 //加密算法：通常是HMAC SHA256
        "typ": "JWT"      //类型：JWT
     } 
     ```

   - 常见加密算法：MD5、SHA、HAMC

     - MD5：message-digest algorithm 5 信息-摘要算法，广泛用于文件校验
     - SHA：Secure Hash Algorithm 安全散列算法，数字签名等密码学应用中重要的工具，安全性高于MD5
     - HMAC：Hash Message Authentication Code 散列消息鉴别码，基于密钥的Hash算法的认证协议。用公开函数和密钥产生一个固定长度的值作为认证标识，用这个标识鉴别消息的完整性。常用于接口签名验证

   - 我们会对头部进行 Base64Url 编码（可解码），得到第一部分数据

2. payload：载荷，就是存放有效信息的地方

   - iss (issuer)：表示签发人
   - exp (expiration time)：表示token过期时间
   - sub (subject)：主题
   - aud (audience)：受众
   - nbf (Not Before)：生效时间
   - iat (Issued At)：签发时间
   - jti (JWT ID)：编号
   - 这部分也会采用 Base64Url 编码，得到第二部分数据。

3. signature：签名，是整个数据的认证信息。一般根据前两步的数据，再加上服务的的密钥 secret（密钥保存在服务端，不能泄露给客户端），通过 Header 中配置的加密算法生成，得到的最终的token。用于验证整个数据完整和可靠性。



项目：https://www.jianshu.com/p/e88d3f8151db

#### JWT交互流程

![image-20220319204234978](https://pic-typora-qc.oss-cn-chengdu.aliyuncs.com/img/202203192042146.png)

1. 应用程序或客户端向授权服务器请求授权
2. 获取到授权后，授权服务器会向应用程序返回访问令牌
3. 应用程序使用访问令牌来访问受保护资源（如API）

因为 JWT 签发的 token 中已经包含了用户的身份信息，并且每次请求都会携带，这样服务就无需保存用户信息，甚至无需去数据库查询，这样就符合了 RESTful 的无状态规范

#### JWT存在的问题

JWT 也不是天衣无缝，由客户端维护登录状态带来的一些问题在这里依然存在，举例如下：

1. 续签问题，这是被很多人诟病的问题之一，传统的 cookie+session 的方案天然的支持续签，但是 jwt 由于服务端不保存用户状态，因此很难完美解决续签问题，如果引入 redis，虽然可以解决问题，但是 jwt 也变得不伦不类了。
2. 注销问题，由于服务端不再保存用户信息，所以一般可以通过修改 secret 来实现注销，服务端 secret 修改后，已经颁发的未过期的 token 就会认证失败，进而实现注销，不过毕竟没有传统的注销方便。
3. 密码重置，密码重置后，原本的 token 依然可以访问系统，这时候也需要强制修改 secret。
4. 基于第 2 点和第 3 点，一般建议不同用户取不同 secret(密钥)

#### Java-jwt

是Java推荐的JWT实现库而已，通过maven导入即可使用

~~~java
//产生加密token
String token = JWT.create()
  .withExpiresAt(newDate(System.currentTimeMillis()))  //设置过期时间
  .withAudience("user1") //设置接受方信息，一般时登录用户
  .sign(Algorithm.HMAC256("111111"));  //使用HMAC算法，111111作为密钥加密

//解密Token获取负载信息并验证token是否有效
String userId = JWT.decode(token).getAudience().get(0);
Assertions.assertEquals("user1", userId);
JWTVerifier jwtVerifier = JWT.require(Algorithm.HMAC256("111111")).build();
jwtVerifier.verify(token);


~~~



---

---



### HTTP状态码

当浏览者访问一个网页时，浏览者的浏览器会向网页所在服务器发出请求。当浏览器接收并显示网页前，此网页所在的服务器会返回一个包含 HTTP 状态码的信息头（server header）用以响应浏览器的请求

#### 分类

常见的状态码值

##### 2**

200：请求成功

##### 3**

301、302代表某个请求的资源被转移到新的URL

301：代表永久性转移

302：暂时性转移

##### 4**

400：Bad Request。客户端请求的语法错误，服务器无法理解

401：Unauthorized。请求要求用户的身份认证

403：Forbidded。服务器理解客户端的请求，但是拒绝执行此请求

404：Not Found。服务器无法根据客户端的请求找到资源

##### 5**

500：Internal Server Error。服务器内部错误，无法完成请求

502：Bad Gateway。作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应

503：Service Unavailable。由于超载或系统维护，服务器暂时的无法处理客户端的请求





---

默认sso只能解决登录认证问题，不能解决授权问题，即/user和/order需要不同的权限

网关处认证、授权





